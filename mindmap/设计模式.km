{
    "root": {
        "data": {
            "id": "c2f7fe834534",
            "created": 1622015988,
            "text": "设计模式",
            "currentstyle": "default",
            "expandState": "expand"
        },
        "children": [
            {
                "data": {
                    "id": "cbn0pearg2o0",
                    "created": 1622016058181,
                    "text": "行为型模式\n管理协调对象或类之间的动作，划分对象或类的功能和范围",
                    "note": null,
                    "expandState": "expand",
                    "layout": null
                },
                "children": [
                    {
                        "data": {
                            "id": "cbn0rgne7s00",
                            "created": 1622016220026,
                            "text": "类的行为型模式\n使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责",
                            "layout": null,
                            "expandState": "expand"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cbn5mbgrdc80",
                                    "created": 1622029922470,
                                    "text": "解释器模式",
                                    "expandState": "expand",
                                    "layout": null
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "cbn5mhktifk0",
                                            "created": 1622029935776,
                                            "text": "动机\n如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器,该解释器通过解释这些句子来解决该问题。例如正则表达式，SpEL。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "cbos4o8fwh40",
                                    "created": 1622194985195,
                                    "text": "模板方法",
                                    "expandState": "expand",
                                    "layout": null
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "cbos4vaho200",
                                            "created": 1622195000556,
                                            "text": "意图\n定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbos4z4dl080",
                                            "created": 1622195008894,
                                            "text": "动机\n通过使用抽象操作定义一个算法中的一些步骤，模板方法确定了它们的先后顺序，并允许子类改变其中具体步骤的实现方式。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbos52ly3k00",
                                            "created": 1622195016486,
                                            "text": "适用性\n一次性实现一个算法的不变部分，并将可变的行为留给子类来实现\n各子类中公共的行为应该被提取出来集中到一个公共父类中以避免代码重复\n控制子类扩展，模板方法只在特定点调用\"hook\"操作，这样就只允许在这些点进行扩展",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbos5a57foo0",
                                            "created": 1622195032888,
                                            "text": "结构",
                                            "image": "https://li-qr.github.io/mindmap/images/design-partterns/模板方法结构.png",
                                            "imageTitle": "",
                                            "imageSize": {
                                                "width": 200,
                                                "height": 114
                                            },
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbos5mng40w0",
                                            "created": 1622195060113,
                                            "text": "协作\nConcreteClass靠AbstractClass来实现算法中不变的步骤",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbos5rfzrm80",
                                            "created": 1622195070546,
                                            "text": "效果\n模板方法是一种代码复用的基本技术，在类库中尤为重要，它们提取了类库中的公共行为\n模板方法中的钩子操作提供了缺省的行为，一般是一个空操作，子类只有在需要的时候才进行扩展",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbos5zbj9880",
                                            "created": 1622195087691,
                                            "text": "实现\n尽量减少原语操作 定义模板方法的一个重要目的是尽量减少一个子类具体实现该算法时必须重定义的那些原语操作的数目。需要重定义的操作越多，客户程序就越冗长。\n命名约定 可以给应被重定义的那些操作的名字加上一个前缀以识别它们。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbos65euq3k0",
                                            "created": 1622195100952,
                                            "text": "相关模式\n Factory Method 常被模板方法凋用\nStrategy  模板方法使用继承来改变算法的一部分。Strategy使用委托来改变整个算法.",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "cbn0rvt4pg00",
                            "created": 1622016253025,
                            "text": "对象的行为型模式\n使用对象的聚合关联关系来分配行为，根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。",
                            "layout": null,
                            "expandState": "expand"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cbn2ybzyn0o0",
                                    "created": 1622022400671,
                                    "text": "责任链模式",
                                    "expandState": "expand",
                                    "layout": null
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "cbn2yvgdym80",
                                            "created": 1622022443023,
                                            "text": "意图\n使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链,并沿着这条链传递该请求，直到有一个对象处理它为止。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbn300secjk0",
                                            "created": 1622022532998,
                                            "text": "动机\n命令的发送者并不明确的知道最终执行请求的接收者，接收者按照一定的先后关系组成一条链，其中收到请求的接收者要么亲自处理命令，要么向链的下游转发请求。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbn35kagvlk0",
                                            "created": 1622022967270,
                                            "text": "适用性\n有多个对象可以处理一个请求，哪个对象处理该请求运行时自动确定\n在不明确指定接收者的情况下，向多个对象中的一个提交请求\n可处理请求的对象集合应被动态指定",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbn3608ri6w0",
                                            "created": 1622023001995,
                                            "text": "结构",
                                            "image": "https://li-qr.github.io/mindmap/images/design-partterns/责任链模式结构.png",
                                            "imageTitle": "",
                                            "imageSize": {
                                                "width": 200,
                                                "height": 100
                                            },
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbn4vkvxu000",
                                            "created": 1622027827146,
                                            "text": "优点\n降低耦合度，接收者和发送者互相不耦合\n增加了给对象指派职责的灵活性，可以再运行时动态对职责链进行修改",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbn4w09djmo0",
                                            "created": 1622027860611,
                                            "text": "缺点\n不保证一定会被处理，可能链内没有可以处理请求的对象，或者链没有正确的配置",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbnpv193w1c0",
                                            "created": 1622087027715,
                                            "text": "相关模式\nComposite模式可被用来实现宏命令。\nMemento模式可用来保持某个状态，命令用这一状态来取消它的效果。在被放入历史表列前必须被拷贝的命令起到一种原型的作用。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "cbn0t71ky7k0",
                                    "created": 1622016355845,
                                    "text": "命令模式",
                                    "expandState": "expand",
                                    "layout": null
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "cbn0tejizq80",
                                            "created": 1622016372167,
                                            "text": "动机\n解耦请求发出者和请求接受者，使得两者之间不需要有引用关系甚至不知道互相存在。发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbn0uxrqh3c0",
                                            "created": 1622016492387,
                                            "text": "定义\n将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求进行存储、排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbn14o4akpk0",
                                            "created": 1622017255020,
                                            "text": "结构",
                                            "image": "https://li-qr.github.io/mindmap/images/design-partterns/命令模式结构.png",
                                            "imageTitle": "",
                                            "imageSize": {
                                                "width": 200,
                                                "height": 157
                                            },
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbn15rwxpb40",
                                            "created": 1622017341646,
                                            "text": "时序图",
                                            "image": "https://li-qr.github.io/mindmap/images/design-partterns/命令模式时序图.png",
                                            "imageTitle": "",
                                            "imageSize": {
                                                "width": 200,
                                                "height": 121
                                            },
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbn1715prmo0",
                                            "created": 1622017440132,
                                            "text": "优点\n降低系统的耦合度。\n新的命令可以很容易地加入到系统中。\n可以比较容易地设计一个命令队列和宏命令（组合命令）。\n可以方便地实现对请求的Undo和Redo",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbn17l4zt7k0",
                                            "created": 1622017483624,
                                            "text": "缺点\n使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbn17sc4q000",
                                            "created": 1622017499293,
                                            "text": "适用性\n系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。\n系统需要在不同的时间指定请求、将请求排队和执行请求。\n系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，在Command接口中添加一个Unexecute操作用来取消上一次的Execute操作\n记录命令日志，在Command接口中添加加载操作和存储操作，这样可以故障恢复\n将一组操作组合成一个命令，即原子和宏命令",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbn2x7zjktk0",
                                            "created": 1622022313575,
                                            "text": "相关模式\nComposite模式可被用来实现宏命令。\nMemento模式可用来保持某个状态，命令用这一状态来取消它的效果。在被放入历史表列前必须被拷贝的命令起到一种原型的作用。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "cbno12agcyo0",
                                    "created": 1622081857938,
                                    "text": "迭代器模式",
                                    "expandState": "expand",
                                    "layout": null
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "cbno2z46slk0",
                                            "created": 1622082007758,
                                            "text": "意图\n提供一种不需要暴露对象内部成员变量的方法来顺序访问一个集合对象中各个元素。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbno38e2i8w0",
                                            "created": 1622082027946,
                                            "text": "动机\n将对集合类的访问和遍历从集合类对象中分离出来放入一个迭代器对象中。迭代器类定义了一个访问该列表元素的接口。迭代器对象负责跟踪当前元素。不同的迭代器实现可以实现不同的遍历策略而无需体现在集合类接口中。\n\n迭代器和集合类是耦合在一起的。集合对象负责创建相应的迭代器，并负责关联集合类和迭代器。创建迭代器是一个Factory Method模式。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbno3eqrbls0",
                                            "created": 1622082041774,
                                            "text": "适用性\n\n访问一个集合对象的内容而无需暴露它的内部表示\n支持对集合对象的多种遍历\n为遍历不同的集合结构提供一个统一的接口，即支持多态迭代",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbno3lv1wdc0",
                                            "created": 1622082057271,
                                            "text": "结构",
                                            "image": "https://li-qr.github.io/mindmap/images/design-partterns/迭代器模式结构.png",
                                            "imageTitle": "",
                                            "imageSize": {
                                                "width": 200,
                                                "height": 93
                                            },
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbno5oioci80",
                                            "created": 1622082219781,
                                            "text": "优点\n它支持以不同的方式遍历一个集合，复杂的集合可用多种方式进行遍历\n迭代器简化了集合的接口，有了迭代器的遍历接口，集合本身就不再需要类似的遍历接口\n在同一个集合上可以有多个遍历，每个迭代器保持它自己的遍历状态，因此可以同时进行多个遍历",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbnpup44pk00",
                                            "created": 1622087001293,
                                            "text": "相关模式\nComposite：迭代器常被应用到象复合这样的递归结构上。\nFactory Method：多态迭代器靠Factory Method来例化适当的迭代器子类。\nMemento：常与迭代器模式一起使用。迭代器可使用一个memento来捕获一个迭代的状态。迭代器在其内部存储memento。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "cbnohcjqibs0",
                                    "created": 1622083134094,
                                    "text": "中介者模式",
                                    "expandState": "expand",
                                    "layout": null
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "cbnoiioxkcw0",
                                            "created": 1622083225833,
                                            "text": "定义\n用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbnpsd2nwc80",
                                            "created": 1622086818354,
                                            "text": "动机\n虽然将一个系统分割成许多对象通常可以增强可复用性，但是对象间相互连接又会降低其可复用性。中介者负责控制和协调一组对象间的交互，以使组中的对象不再相互显示引用，这些对象仅知道中介者，减少了相互连接的数目。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbnpshqaqrc0",
                                            "created": 1622086828491,
                                            "text": "适用性\n一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解\n一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象\n想定制一个分布在多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现。\n交互的公共行为，如果需要改变行为则可以增加新的中介者类。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbnpspje9qg0",
                                            "created": 1622086845487,
                                            "text": "结构",
                                            "image": "https://li-qr.github.io/mindmap/images/design-partterns/中介者模式结构.jpeg",
                                            "imageTitle": "",
                                            "imageSize": {
                                                "width": 200,
                                                "height": 87
                                            },
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbnpswz1yzk0",
                                            "created": 1622086861672,
                                            "text": "时序图",
                                            "image": "https://li-qr.github.io/mindmap/images/design-partterns/中介者模式时序图.jpeg",
                                            "imageTitle": "",
                                            "imageSize": {
                                                "width": 200,
                                                "height": 120
                                            },
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbnptjwmzn40",
                                            "created": 1622086911592,
                                            "text": "优点\n减少了子类生成\n它将各Collague解耦\n它简化了对象交互\n它对对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，使你将注意力从对象各自本身的行为转移到它们之间的交互上来。这有助于弄清楚一个系统中的对象是如何交互的",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbnptxem7uo0",
                                            "created": 1622086940977,
                                            "text": "缺点\n在具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbnpu9rafc00",
                                            "created": 1622086967865,
                                            "text": "相关模式\nFacade与中介者的不同之处在于它是对一个对象子系统进行抽象，从而提供了一个更为方便的接口。它的协议是单向的，即Facade对象对这个子 系统类提出请求，但反之则不\n行。相反，Mediator提供了各Colleague对象不支持或不能支持的协作行为，而且协议是多向的。\n\nColleague可使用Observer模式与Mediator通信。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "cbo08gsmzxs0",
                                    "created": 1622116291381,
                                    "text": "备忘录模式",
                                    "expandState": "expand",
                                    "layout": null
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "cbo08qnrqu80",
                                            "created": 1622116312854,
                                            "text": "意图\n在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbo11yyagxs0",
                                            "created": 1622118603466,
                                            "text": "动机\n在不破坏对象的封闭原则基础上，记录一个对像的内部状态，以便随时将对象还原至记录过的状态。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbo124rjb1c0",
                                            "created": 1622118616118,
                                            "text": "适用性\n保存一个对象的状态用于恢复",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbo128kqpps0",
                                            "created": 1622118624414,
                                            "text": "结构",
                                            "image": "https://li-qr.github.io/mindmap/images/design-partterns/备忘录模式结构.png",
                                            "imageTitle": "",
                                            "imageSize": {
                                                "width": 200,
                                                "height": 58
                                            },
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbo12n6d7o80",
                                            "created": 1622118656197,
                                            "text": "协作\n管理器向原发器请求一个备忘录,保留一段时间后,将其送回给原发器\n备忘录是被动的。只有创建备忘录的原发器会对它的状态进行赋值和检索",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbo12vo5c800",
                                            "created": 1622118674686,
                                            "text": "效果\n保持封装边界，把Originator内部信息对其他对象屏蔽\n简化了原发器，让客户端管理它们请求的状态而不是由Originator自己管理，将会简化Originator，并且客户端工作结束时无需通知原发器\n使用备忘录可能代价很高，在拷贝存储大量信息并频繁的创建和恢复的时候\n衡量窄接口和宽接口\n维护备忘录的潜在代价，因为管理器存储备忘录时不知道备忘录中有多少个状态。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbo1391vklc0",
                                            "created": 1622118703814,
                                            "text": "实现\n备忘录的两个接口：原发器所使用的宽接口和其他对象使用的窄接口需要语言支持\n如果备忘录创建和恢复的顺序是可预测的，可以进存储原发器内部状态的增量改变",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbo13gk0lh40",
                                            "created": 1622118720149,
                                            "text": "相关模式\nCommand：命令可使用备忘录来为可撤销的操作维护状态\nIterator：备忘录可用于迭代",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "cbojoc20vds0",
                                    "created": 1622171135979,
                                    "text": "观察者模式",
                                    "expandState": "expand",
                                    "layout": null
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "cbojogwaaa80",
                                            "created": 1622171146516,
                                            "text": "意图\n定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbojoqr51g80",
                                            "created": 1622171167973,
                                            "text": "动机\n将一个系统分割成一系列相互协作的类会导致难以维护相关对象间的一致性。观察者模式解除因维护对象间一致性而带来的耦合。建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbojov362h40",
                                            "created": 1622171177407,
                                            "text": "适用性\n当一个抽象模型有两个方面，其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。\n当对一个对象的改变需要同时改变其它对象,而不知道具体有多少对象有待改变。可以降低对象之间的耦合度。\n当一个对象必须通知其它对象，而你不希望这些对象是紧密耦合的。\n需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbojp2fxb6w0",
                                            "created": 1622171193416,
                                            "text": "结构",
                                            "image": "https://li-qr.github.io/mindmap/images/design-partterns/观察者模式结构.jpeg",
                                            "imageTitle": "",
                                            "imageSize": {
                                                "width": 200,
                                                "height": 82
                                            },
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbojpp96jlc0",
                                            "created": 1622171243075,
                                            "text": "协作\n当ConcreteSubject发生任何可能导致其观察者与其本身状态不一致的改变时,它将通知它的各个观察者。\n在得到一个具体目标的改变通知后, ConcreteObserver对象可向目标对象查询信息。ConcreteObserver使用这些信息以使它的状态与目标对象的状态一致。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbojq5op5a80",
                                            "created": 1622171278841,
                                            "text": "缺点\n 依赖维护不当会导致意外更新。甚至循环调用导致系统崩溃\n观察者的数量和量级如果不进行控制，由于不知道改变目标的最终代价，一个看上去无害的操作可能会引起一系列相关依赖进行更新",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbojpvyobvk0",
                                            "created": 1622171257677,
                                            "text": "优点\n目标和观察者间的抽象耦合\n观察者模式符合“开闭原则”的要求\n支持广播通信，目标发送的通知会广播给所有关联的观察者\n观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbojqu0fmao0",
                                            "created": 1622171331794,
                                            "text": "相关模式\nMediator:通过封装复杂的更新语义, ChangeManager充当目标和观察者之间的中介者。\nSingleto: ChangeManager可使用Singleton模式来保证它是唯一的并且是可全局访问的。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "cbokdtrsnq80",
                                    "created": 1622173133647,
                                    "text": "状态模式",
                                    "expandState": "expand",
                                    "layout": null
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "cbokdxs1x9k0",
                                            "created": 1622173142370,
                                            "text": "意图\n允许一个对象在其内部状态改变时改变行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbokearv6k00",
                                            "created": 1622173170657,
                                            "text": "动机\n在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbokeewiztk0",
                                            "created": 1622173179646,
                                            "text": "适用性\n一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为\n代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cboketjffbk0",
                                            "created": 1622173211505,
                                            "text": "结构",
                                            "image": "https://li-qr.github.io/mindmap/images/design-partterns/状态模式结构.png",
                                            "imageTitle": "",
                                            "imageSize": {
                                                "width": 200,
                                                "height": 76
                                            },
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbokf7llbjs0",
                                            "created": 1622173242111,
                                            "text": "协作\nContext将与状态相关的请求委托给当前的ConcreteState对象处理\nContext可将自身作为一个参数传递给处理该请求的状态对象。这使得状态对象在必要时可访问Context\nContext是客户使用的主要接口。客户可用状态对象来配置一个Context,一旦一个Context配置完毕,它的客户不再需要直接与状态对象打交道\nContext或ConcreteState子类都可决定哪个状态是另外哪一个的后继者,以及是在何种条件下进行状态转换",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbokfid304g0",
                                            "created": 1622173265541,
                                            "text": "优点\n将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为\n允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块\n可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbokfojlmg00",
                                            "created": 1622173278996,
                                            "text": "缺点\n状态模式的使用必然会增加系统类和对象的个数\n状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱\n状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbokfvh1eoo0",
                                            "created": 1622173294079,
                                            "text": "相关模式\nFlyweight解释了何时以及怎样共享状态对象\n状态对象通常是Singleton",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbokg345u1k0",
                                            "created": 1622173310714,
                                            "text": "实现\n可以在Context中实现状态转换，也可以让State自己实现状态流转，需要Context增加一个家口，让State对象显式地设定Context当前的状态。用这种方法分散的逻辑可以很容易地定义新的State子类来修改和扩展该逻辑，缺点是各State子类之间产生了依赖\n用基于映射表的方式映射状态转换，但是对表的查找通常不如函数调用效率高；表只能映射状态不能加入伴随状态转换的一些操作\nState对象是预创建单例还是随时用随时销毁，可根据状态的数量和转换的频率来选择",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "cbor8xp1a800",
                                    "created": 1622192498137,
                                    "text": "策略模式",
                                    "expandState": "expand",
                                    "layout": null
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "cbor94urug00",
                                            "created": 1622192513720,
                                            "text": "意图\n定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbor989p5080",
                                            "created": 1622192521153,
                                            "text": "动机\n完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。使用一些类封装不同的算法，避免把算法硬编码。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbor9cesc1c0",
                                            "created": 1622192530168,
                                            "text": "适用性\n许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法\n需要使用一个算法的不同变体，例如时间优先或空间优先的相同算法\n算法使用客户不应该知道的数据。可使用策略模式隐藏数据结构\n一个类定义了多种行为,并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移人它们各自的Strategy类中以代替这些条件语句",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbor9jdlh1s0",
                                            "created": 1622192545333,
                                            "text": "结构",
                                            "image": "https://li-qr.github.io/mindmap/images/design-partterns/策略模式结构.jpeg",
                                            "imageTitle": "",
                                            "imageSize": {
                                                "width": 200,
                                                "height": 86
                                            },
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbora254q7k0",
                                            "created": 1622192586180,
                                            "text": "协作\nStrategy和Context相互作用以实现选定的算法。当算法被调用时，Context可以将该算法所需要的所有数据都传递给该Stategy。或者, Context可以将自身作为一个参数传递给Strategy操作。这就让Strategy在需要时可以回调Context。\nContext将它的客户的请求转发给它的Strategy。客户通常创建并传递一个ConcreteStrategy对象给该Context;这样,客户仅与Context交互。通常有一系列的ConcreteStrategy类可供客户从中选择。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbora8vl31s0",
                                            "created": 1622192600841,
                                            "text": "优点\nStrategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能\n将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展\n消除了条件语句\n可以选择相同行为的不同实现\n策略模式提供了管理相关的算法族的办法",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cboragowork0",
                                            "created": 1622192617851,
                                            "text": "缺点\n策略模式将造成产生很多策略类\n客户必须了解不同的Strategy类，并自行决定使用哪一个\nContext可能会创建和初始化一些Strategy用不到的参数",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cboramtbrts0",
                                            "created": 1622192631179,
                                            "text": "相关模式\nFlyweight: Strategy对象经常是很好的轻量级对象",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "data": {
                                    "id": "cbose2in0qw0",
                                    "created": 1622195721564,
                                    "text": "访问者模式",
                                    "expandState": "expand",
                                    "layout": null
                                },
                                "children": [
                                    {
                                        "data": {
                                            "id": "cbose9ce0xc0",
                                            "created": 1622195736423,
                                            "text": "意图\n表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbouac5bvpk0",
                                            "created": 1622201071291,
                                            "text": "动机\n使用Visitor模式，必须定义两个类层次: 一个对应于接受操作的元素(Node层次)另一个对应于定义对元素的操作的访问者(NodeVisitor层次)。给访问者类层次增加一个新的子类即可创建一个新的操作。只要不需要增加新的Node子类,我们就可以简单的定义新的NodeVisitor子类以增加新的功能。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbouafxi5xs0",
                                            "created": 1622201079524,
                                            "text": "适用性\n一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作\n需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作“污染”这些对象的类。Visitor使得你可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用Visitor模式让每个应用仅包含需要用到的操作\n定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbouanbfvwg0",
                                            "created": 1622201095604,
                                            "text": "结构",
                                            "image": "https://li-qr.github.io/mindmap/images/design-partterns/访问者模式结构.png",
                                            "imageTitle": "",
                                            "imageSize": {
                                                "width": 200,
                                                "height": 147
                                            },
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cbouayl1j340",
                                            "created": 1622201120129,
                                            "text": "协作\n一个使用Visitor模式的客户必须创建一个ConcreteVisitor对象,然后遍历该对象结构，并用该访问者访问每一个元素。\n当一个元素被访问时，它调用对应于它的类的Visitor操作。如果必要，该元素将自身作为这个操作的一个参数以便该访问者访问它的状态。",
                                            "image": "https://li-qr.github.io/mindmap/images/design-partterns/访问者模式协作.png",
                                            "imageTitle": "",
                                            "imageSize": {
                                                "width": 200,
                                                "height": 83
                                            },
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cboubb4295s0",
                                            "created": 1622201147401,
                                            "text": "优点\n访问者模式使得易于增加新的操作，访问者使得增加依赖于复杂对象结构的构件的操作变得容易了。仅需增加一个新的访问者即可在一个对象结构上定义一个新的操作。相反，如果每个功能都分散在多个类之上的话，定义新的操作时必须修改每一类。\n访问者集中相关的操作而分离无关的操作，相关的行为不是分布在定义该对象结构的各个类上，而是集中在一个访问者中。无关行为却被分别放在它们各自的访问者子类中。这就既简化了这些元素的类，也简化了在这些访问者中定义的算法。所有与它的算法相关的数据结构都可以被隐藏在访问者中。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cboubjbvbao0",
                                            "created": 1622201165287,
                                            "text": "缺点\n增加新的ConcreteElement类很困难，Visitor模式使得难以增加新的Element的子类。每添加一个新的ConcreteElement都要在Vistor中添加一个新的抽象操作，并在每一个ConcretVisitor类中实现相应的操作。有时可以在Visitor中提供一个缺省的实现，这一实现可以被大多数的ConcreteVisitor继承，但这与其说是一个规律还不如说是一种例外。所以在应用访问者模式时考虑关键的问题是系统的哪个部分会经常变化，是作用于对象结构上的算法呢还是构成该结构的各个对象的类。如果老是有新的ConcretElement类加入进来的话，Vistor类层次将变得难以维护。在这种情况下，直接在构成该结构的类中定义这些操作可能更容易一些。如果Element类层次是稳定的，而你不断地增加操作获修改算法，访向者模式可以帮助你管理这些改动。\n通过类层次进行访问，一个迭代器可以通过调用节点对象的特定操作来遍历整个对象结构,同时访问这些对象。但是迭代器不能对具有不同元素类型的对象结构进行操作。\n累积状态，当访问者访问对象结构中的每一个元素时，它可能会累积状态。如果没有访问者，这一状态将作为额外的参数传递给进行遍历的操作，或者定义为全局变量。\n破坏封装，访问者方法假定ConcreteElement接口的功能足够强，足以让访问者进行它们的工作。结果是，该模式常常迫使你提供访问元素内部状态的公共操作，这可能会破坏它的封装性。",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    },
                                    {
                                        "data": {
                                            "id": "cboubs8fr680",
                                            "created": 1622201184671,
                                            "text": "相关模式\nComposite，访问者可以用于对一-个由Composite模式定义的对象结构进行操作\nInterpreter，访问者可以用于解释",
                                            "layout": null,
                                            "expandState": "expand"
                                        },
                                        "children": []
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        ]
    },
    "template": "default",
    "theme": "classic",
    "version": "1.4.43"
}