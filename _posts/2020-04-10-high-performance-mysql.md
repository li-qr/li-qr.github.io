---
title: 高性能MySQL摘要
categories:
- MySQL
description: 高性能MySQL摘要
permalink: "/posts/high-performance-mysql"
excerpt: 内容全部源自《高性能MySQL第三版》，取自里面的重点内容摘要。包括MySQL架构、性能、索引、查询优化、高级特性等。
---

# Schema与数据类型优化

## 选择优化的数据类型

选择可以满足需求的占用空间最小的数据类型，因为他们占用更少的磁、内存和cpu缓存，并且处理时需要的CPU周期也更少。

尽量使用内建类型和简单类型比如时间不使用VARCHAR，IP尽量使用整型，因为他们本来就是无符号整型。
当可为NULL的列被索引时，每个索引记录需要一个额外的字节，
避免NULL，如果查询中包含可为NULL的列，因为可为NULL的列使得 索引、索引统计和值比较都更复杂。可为NULL的列会使用更多的存储空间。在MyISAM里甚至还可能导致固定大小的例如只有一个整数列的索引）变成可变大小的索引。
有例外，InnoDB使用单独的位（bit）存储NULL值，所以对于稀疏数据有很好的空间效率。但这一点不适用于MyISAM。

在为列选择数据类型时，第一步需要确定合适的大类型：数字、字符串、时间等。第二步是选择具体类型。

MySQL支持很多数据类型的别名，但是实际使用的类型都是一样
## 整数类型

TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT。分别使用8，16，24，32，64 位存储空间。
分有符号和无符号。MySQL可以为整数类型指定宽度，它不会 限制值的合法范围，只是规定了MySQL的一些交互工具用来显示字符的个数。

## 实数类型

实数是带有小数部分的数字。然而，它们不只是为了存储小数部分；也可以使用DECIMAL 存储比BIGINT还大的整数。

对于DECIMAL列，可以指定小数点前后所允许的最大位数。这会影响列的空间消耗。MySQL 5.0和更高版本将数字打包保存到一个二进制字符 串中（每4个字节存9个数字）。例如，DECIMAL（18,9）小数点两边将各存储9个数字，一共使用9个字节：小数点前的数字用4个字节，小数点后的数字用4个字节，小数点本身占1个字节。

## 字符串类

### VARCHAR

VARCHAR类型用于存储可变长字符串，VARCHAR需要使用1或2个额外字节记录字符串的长度：如果列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。
如果UPDATE使长度变长，则InnoDB需要分裂页使行可以放进页内。

### CHAR
定长，不需要额外记录长度。

### BLOB和TEXT

BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。
BLOB是SMALLBLOB的同义词，TEXT是SMALLTEXT的同义词。
当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域 来进行存储，此时每个值在行内需要1～4个字节存储一个指针，然后在外部存储区域存储实 际的值。
只对每个列的最 前max_sort_length字节排序。

### ENUM

枚举额外存储枚举值并在列存位置。所以枚举是按照位置整数来排序，并且修改的时候需要ALTER TABLE，如果数据量大枚举在映射到值时开销也会大。

### 日期和时间

DATETIME这个类型能保存大范围的值，从1001年到9999年，精度为秒。它把日期和时间封装到 格式为YYYYMMDDHHMMSS的整数中，与时区无关。使用8个字节的存储空间。

TIMESTAMP 类型保存了从1970年1月1日以来的秒数，它和UNIX时间戳相同。TIMESTAMP只使用4个字节的存储空间，因此只能表示从1970年到2038年。MySQL提供了 FROM_UNIXTIME()函数把Unix时间戳转换为日期，并提供了UNIX_TIMESTAMP()函数 把日期转换为Unix时间戳。
TIMESTAMP显示的值也依赖于时区。因此，存储值为0的TIMESTAMP在美国东部时区显示为“1969-12-31 19:00:00”.

### 位数据类型

BIT 这样MyISAM只使用3个字节就能存储这17个BIT列。其他存储引擎例如Memory和InnoDB，为每个BIT列使用一个足够存储的最小整数类型来存放，所以不能节省存储空间。
MySQL把BIT当作字符串类型，而不是数字类型。当检索BIT（1）的值时，结果是一个包含二进制0或1值的字符串，而不是ASCII码的“0”或“1”。然而，在数字上下文的场景中
检索时，结果将是位字符串转换成的数字。

SET 改变列定义代价高，可以使用整型替代。

### 随机主键

会导致INSERT以及一些 SELECT语句变得很慢，这会导致页分 裂、磁盘随机访问，以及对于聚簇存储引擎产生聚簇索引碎片。SELECT语句会变得更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方。 随机值导致缓存失效。


## MySQL schema设计中的陷阱

不宜太多的列，MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷 贝数据，然后在服务器层将缓冲内容解码成各个列。

不宜太多的关联，MySQL最多JOIN 61张表。 

## 范式和反范式

### 范式

范式化的更新操作通常比反范式化要快。
当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据。
范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快。
范式会把一些信息单独存在一张表中，所以不需要使用DISTINCT或者GROUP BY就可以查询。
但是范式需要关联

### 反范式

反范式可以不使用关联，并且增加一个索引就可以查询。

范式和反范式不一定要极端，在范式化下也可以少许冗余以便查询。

### 缓存表或汇总表

可以使用缓存表或汇总表冗余统计数据。汇总表加锁会影响其他写入，所以可以分散汇总数据比如把汇总结果分散在100行，随机进行更新。最后取SUM

# 创建高性能的索引

## 索引基础

MySQL索引对多列索引使用最左前缀列

### 索引的类型

#### B-Tree索引

MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照原数据格式进行存储。MyISAM索引通过数
据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。

B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。

![B-Tree索引](/assets/images/44607b3d-14ab-42c6-9f84-48a56486cc9c.png)

使用B-Tree索引不需要全表扫描，通过比较节点页的值和要查找的值逐渐向下层查找。

叶子节点指向的是被索引的数据而不是其他的节点页。因为B-Tree对索引列是顺序存储的，所以很适合范围查找。

下图标识索引last_name、frst_name和生日的储存形式

![B-Tree索引举例](/assets/images/10fbb641-ddd9-4c91-a73d-1dd16caaf14a.png)

B-Tree所以适用于全值匹配、范围匹配、匹配左列、匹配列值的前缀，同样精确匹配左前列范围匹配后一列。同样B-Tree索引适用于Ordr By。

B-Tree的限制

+ 如果不是按照索引的最左列开始查找，则无法使用索引。
+ 不能跳过索引中的列。
+ 如果查询中有某个列的范围查询，
