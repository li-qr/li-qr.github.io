---
title: 高性能MySQL摘要
categories:
- MySQL
description: 高性能MySQL摘要
permalink: "/posts/high-performance-mysql"
excerpt: 内容全部源自《高性能MySQL第三版》，取自里面的重点内容摘要。包括MySQL架构、性能、索引、查询优化、高级特性等。
---

# Schema与数据类型优化

## 选择优化的数据类型

选择可以满足需求的占用空间最小的数据类型，因为他们占用更少的磁、内存和cpu缓存，并且处理时需要的CPU周期也更少。

尽量使用内建类型和简单类型比如时间不使用VARCHAR，IP尽量使用整型，因为他们本来就是无符号整型。
当可为NULL的列被索引时，每个索引记录需要一个额外的字节，
避免NULL，如果查询中包含可为NULL的列，因为可为NULL的列使得 索引、索引统计和值比较都更复杂。可为NULL的列会使用更多的存储空间。在MyISAM里甚至还可能导致固定大小的例如只有一个整数列的索引）变成可变大小的索引。
有例外，InnoDB使用单独的位（bit）存储NULL值，所以对于稀疏数据有很好的空间效率。但这一点不适用于MyISAM。

在为列选择数据类型时，第一步需要确定合适的大类型：数字、字符串、时间等。第二步是选择具体类型。

MySQL支持很多数据类型的别名，但是实际使用的类型都是一样
## 整数类型

TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT。分别使用8，16，24，32，64 位存储空间。
分有符号和无符号。MySQL可以为整数类型指定宽度，它不会 限制值的合法范围，只是规定了MySQL的一些交互工具用来显示字符的个数。

## 实数类型

实数是带有小数部分的数字。然而，它们不只是为了存储小数部分；也可以使用DECIMAL 存储比BIGINT还大的整数。

对于DECIMAL列，可以指定小数点前后所允许的最大位数。这会影响列的空间消耗。MySQL 5.0和更高版本将数字打包保存到一个二进制字符 串中（每4个字节存9个数字）。例如，DECIMAL（18,9）小数点两边将各存储9个数字，一共使用9个字节：小数点前的数字用4个字节，小数点后的数字用4个字节，小数点本身占1个字节。

## 字符串类

### VARCHAR

VARCHAR类型用于存储可变长字符串，VARCHAR需要使用1或2个额外字节记录字符串的长度：如果列的最大长度小于或等于255字节，则只使用1个字节表示，否则使用2个字节。
如果UPDATE使长度变长，则InnoDB需要分裂页使行可以放进页内。

### CHAR
定长，不需要额外记录长度。

### BLOB和TEXT

BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。
BLOB是SMALLBLOB的同义词，TEXT是SMALLTEXT的同义词。
当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域 来进行存储，此时每个值在行内需要1～4个字节存储一个指针，然后在外部存储区域存储实 际的值。
只对每个列的最 前max_sort_length字节排序。

### ENUM

枚举额外存储枚举值并在列存位置。所以枚举是按照位置整数来排序，并且修改的时候需要ALTER TABLE，如果数据量大枚举在映射到值时开销也会大。

### 日期和时间

DATETIME这个类型能保存大范围的值，从1001年到9999年，精度为秒。它把日期和时间封装到 格式为YYYYMMDDHHMMSS的整数中，与时区无关。使用8个字节的存储空间。

TIMESTAMP 类型保存了从1970年1月1日以来的秒数，它和UNIX时间戳相同。TIMESTAMP只使用4个字节的存储空间，因此只能表示从1970年到2038年。MySQL提供了 FROM_UNIXTIME()函数把Unix时间戳转换为日期，并提供了UNIX_TIMESTAMP()函数 把日期转换为Unix时间戳。
TIMESTAMP显示的值也依赖于时区。因此，存储值为0的TIMESTAMP在美国东部时区显示为“1969-12-31 19:00:00”.

### 位数据类型

BIT 这样MyISAM只使用3个字节就能存储这17个BIT列。其他存储引擎例如Memory和InnoDB，为每个BIT列使用一个足够存储的最小整数类型来存放，所以不能节省存储空间。
MySQL把BIT当作字符串类型，而不是数字类型。当检索BIT（1）的值时，结果是一个包含二进制0或1值的字符串，而不是ASCII码的“0”或“1”。然而，在数字上下文的场景中
检索时，结果将是位字符串转换成的数字。

SET 改变列定义代价高，可以使用整型替代。

### 随机主键

会导致INSERT以及一些 SELECT语句变得很慢，这会导致页分 裂、磁盘随机访问，以及对于聚簇存储引擎产生聚簇索引碎片。SELECT语句会变得更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方。 随机值导致缓存失效。


## MySQL schema设计中的陷阱

不宜太多的列，MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷 贝数据，然后在服务器层将缓冲内容解码成各个列。

不宜太多的关联，MySQL最多JOIN 61张表。 

## 范式和反范式

### 范式

范式化的更新操作通常比反范式化要快。
当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据。
范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快。
范式会把一些信息单独存在一张表中，所以不需要使用DISTINCT或者GROUP BY就可以查询。
但是范式需要关联

### 反范式

反范式可以不使用关联，并且增加一个索引就可以查询。

范式和反范式不一定要极端，在范式化下也可以少许冗余以便查询。

### 缓存表或汇总表

可以使用缓存表或汇总表冗余统计数据。汇总表加锁会影响其他写入，所以可以分散汇总数据比如把汇总结果分散在100行，随机进行更新。最后取SUM

# 创建高性能的索引

## 索引基础

MySQL索引对多列索引使用最左前缀列

### 索引的类型

#### B-Tree索引

MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照原数据格式进行存储。MyISAM索引通过数
据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。

B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。

![B-Tree索引](/assets/images/44607b3d-14ab-42c6-9f84-48a56486cc9c.png)

使用B-Tree索引不需要全表扫描，通过比较节点页的值和要查找的值逐渐向下层查找。

叶子节点指向的是被索引的数据而不是其他的节点页。因为B-Tree对索引列是顺序存储的，所以很适合范围查找。

下图标识索引last_name、frst_name和生日的储存形式

![B-Tree索引举例](/assets/images/10fbb641-ddd9-4c91-a73d-1dd16caaf14a.png)

B-Tree所以适用于全值匹配、范围匹配、匹配左列、匹配列值的前缀，同样精确匹配左前列范围匹配后一列。同样B-Tree索引适用于Ordr By。

B-Tree的限制

+ 如果不是按照索引的最左列开始查找，则无法使用索引。
+ 不能跳过索引中的列。
+ 如果查询中有某个列的范围查询，

#### 哈希索引

把所有索引列计算一个哈希值，如果哈希冲突以链表方式解决。要避免冲突问题，必须在WHERE条件中带入哈希值和对应列值。同时在哈希表中保存指向数据的指针。哈希索引只支持精确匹配。

限制：

+ 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读 取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明 显。
+ 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。
+ 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来 计算哈希值的。
+ 哈希索引只支持等值比较查询，包括=、IN()、<=>（注意<>和<=>是不同的操作）。也不支 持任何范围查询
+ 访问哈希索引的数据非常快，除非有很多哈希冲突
+ 如果哈希冲突很多的话，在冲突多的索引上操作代价很大
  
InnoDB内建“自适应哈希索引”。当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引之上再创建一个哈希索引，用户无法控制或者配置，不过可以关闭。

#### 空间数据索引（R-Tree）

#### 全文索引

## 索引的优点

索引可以让服务器快速地定位到表的指定位置。

最常见的B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起。

因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。

索引大大减少了服务器需要扫描的数据量

索引可以帮助服务器避免排序和临时表

索引可以将随机I/O变为顺序I/O

## 高性能的索引策略

### 独立的列

不能在索引上使用表达式也不是函数

### 前缀索引和索引选择性

前缀索引最好根据选择性设计索引的前缀长度，选择性是指不重复的索引值和数据表的记录总数的比值。

### 多列索引

如果在每个字段上都单独加索引，服务器能够同时使用这两个单列索引进行扫描，并将结果进行合并。这种算法有三个变种：OR条件的联合AND条件的相交组合前两种情况的联合及相交。

+ 当出现服务器对多个索引做相交操作时（通常有多个AND条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。
+ 当服务器需要对多个索引做联合操作时（通常有多个OR条件），通常需要耗费大量CPU和内存资源在算法的缓存、排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候。
+ 优化器不会把这些计算到“查询成本”中，优化器只关心随机页面读取。这会使得查询的成本被“低估”.


### 合适的索引列顺序

正确的索引列顺序需要考虑order by 和 group by 的需要。

将选择性最高的列放到索引最前列。

### 聚簇索引


聚簇索引不是索引的类型而是一种数据存储方式。指索引和数据保存在同一个结构中。B-Tree的聚簇索引存放在叶子页中，一张表只能有一个聚簇索引。InnoDB通过主键聚簇数据。如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。

优点：

+ 可以把相关数据保存在一起。
+ 数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。
+ 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

缺点：

+ 聚簇数据最大限度地提高了I/O密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了。
+ 插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用OPTIMIZETABLE命令重新组织一下表。
+ 更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。
+ 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。
+ 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。
+ 二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。
+ 二级索引访问需要两次索引查找，而不是一次。二级索引保存的是主键值。

#### InnoDB和MyISAM的数据分布对比（聚簇索引和非聚簇索引的数据分布有区别）

MyISAM按照数据插入的顺序存储在磁盘上，索引只存了数据的地址。

![非聚簇索引](/assets/images/04822719-a817-4bc2-9bc0-b6d3e3eb1dd5.JPG)

MyISAM中主键索引和其他索引在结构上没有什么不同。主键索引就是一个名为PRIMARY的唯一非空索引。

InnoDB 数据和所以存储在一起,数据插入主键不过不是顺序会导致列分页和碎片，而二级索引存储的是主键。

区别：

![区别](/assets/images/bad2377f-c4cb-4a3c-968d-561c9b1a399b.PNG)

聚集索引的顺序插入：

![聚集索引的顺序插入](/assets/images/b424e69d-ef4b-4d4c-8bd2-20bf5bc742d4.PNG)

聚簇索引的非顺序插入：

+ 写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB在插入之前不得不先找到并从磁盘读取目标页到内存中。这将导致大量的随机I/O。
+ 因为写入是乱序的，InnoDB不得不频繁地做页分裂操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。
+ 由于频繁的页分裂，页会变得稀疏并被不规则地填充，所以最终数据会有碎片。
  
### 覆盖索引

MySQL也可以使用索引来直接获取列的数据，这样就不再需要读取数据行。如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”

优点：

+ 索引条目通常远小于数据行大小，所以如果只需要读取索引，那MySQL就会极大地减少数据访问量。这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。覆盖索引对于I/O密集型的应用也有帮助，因为索引比数据更小，更容易全部放入内存中
+ 因为索引是按照列值顺序存储的（至少在单个页内是如此），所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少得多。
+ 一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。这可能会导致严重的性能问题，尤其是那些系统调用占了数据访问中的最大开销的场景。
+ 由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。

select * 不能使用覆盖索引，LIKE操作不能使用覆盖索引。

如果无法使用覆盖索引，可以使用 **延迟关联** （在join中使用子查询）

InnoDB的二级索引会存储主键，所以select主键和二级索引的操作会覆盖查询。

### 使用索引扫描来做排序

MySQL有两种方式可以生成有序的结果：通过排序操作；或者按索引顺序扫描

MySQL可以使用同一个索引既满足排序，又用于查找行。因此，如果可能，设计索引时应该尽可能地同时满足这两种任务

只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能够使用索引来对结果做排序(14)。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。ORDER BY子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求；否则，MySQL都需要执行排序操作，而无法利用索引排序。
有一种情况下ORDER  BY子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。（select a,b from table where a=1 order by b）

join 自身的时候order by无法使用索引

### 压缩（前缀压缩）索引

MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中,例如，索引块中的第一个值是“perform”，第二个值是“performance”，那么第二个值的前缀压缩后存储的是类似“7,ance”

### 冗余和重复索引

重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。冗余索引和重复索引有一些不同。如果创建了索引（A，B），再创建索引（A）就是冗余索引

### 未使用的索引

删除即可

### 索引和锁

InnoDB只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。但这只有当InnoDB在存储引擎层能够过滤掉所有不需要的行时才有效。如果索引无法过滤掉无效的行，那么在InnoDB检索到数据并返回给服务器层以后，MySQL服务器才能应用WHERE子句(19)。

InnoDB在二级索引上使用共享（读）锁，但访问主键索引需要排他（写）锁。

### 索引碎片化

有三种类型的数据碎片：

+ 行碎片，这种碎片指的是数据行被存储为多个地方的多个片段中。
+ 行间碎片，行间碎片是指逻辑上顺序的页，或者行在磁盘上不是顺序存储的。
+ 剩余空间碎片，剩余空间碎片是指数据页中有大量的空余空间。这会导致服务器读取大量不需要的数据，从而造成浪费。
  
# 查询性能优化