---
title: 从Paxos到ZooKeeper分布式一致性原理与实践摘要
categories:
- ZooKeeper
- JAVA
- 分布式
description: 从Paxos到ZooKeeper分布式一致性原理与实践摘要
permalink: "/posts/from-paxos-to-zookeeper"
excerpt: 内容全部源自《从Paxos到ZooKeeper分布式一致性原理与实践》，取自里面的重点内容摘要。包括分布式架构、一致性协议、ZooKeeper与Paxos、ZooKeeper典型使用场景等。
---

# 分布式架构

## 从集中式到分布式

### 集中式的特点

集中式系统部署结构简单，无须分布式协作问题

### 分布式的特点

分布式系统的定义——《分布式系统概念与设计》

> 分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。

一个标准的分布式系统在没有任何特定业务逻辑约束的情况下，会有如下几个特征：

+ 分布性, 分布式系统中的多台计算机都会在空间上随意分布，同时机器的分布情况也会随意变动。
+ 对等性, 分布式系统中的计算机没有主从之分，这里面的主从是指没有控制整个系统的主机也没有被控制的主机。
+ 并发性, 多个节点并发操作共享资源
+ 缺乏全局时钟, 分布式系统缺乏全局的时钟序列控制
+ 故障总是会发生 
  
### 分布式环境的各种问题

+ 通信异常
+ 网络分区
+ 三态（成功、失败、与超时）
+ 节点故障

## 从ACID到CAP/BASE

### ACID

事务可以在并发情况下提供一个隔离方法以防止互相干扰。并且为数据库提供了一个从失败中恢复的方法，和数据库即使在异常状态下仍能保持数据一致性的方法。

### 分布式事务

由于在分布式环境中会出现[各种问题](/posts/from-paxos-to-zookeeper#分布式环境的各种问题)，所以需要分布式事务。

分布式事务是指事务的参与者、支持事务的服务器、资源服务器一级事务管理器分布在分布式环境中。通常可以把一系列分布式操作序列称为子事务，因此分布式事务也可以被定义为一种嵌套型事务，同时也具有了ACID属性。

### CAP和BASE理论

ACID在分布式环境严格的一致性难以保证可用性，因此出现了CAP和BASE理论。

#### CAP

C-一致性(Consistency)，A-可用性(Availability)，P-分区容错性(Partition tolerance)。一个分布式系统最多只能满足其中两项。

##### 一致性

分布式系统中的一致性指多个副本之间能否保持一致的特性。对一个节点的更新同步到其他节点。

##### 可用性

可用性指对用户的每一个请求总是能在有限的时间内返回结果。重点在于有限的时间和返回结果。有限时间指一个合理的返回时间；返回结果是指一个明确是成功或失败的结果。

##### 分区容错性

分布式系统在遇到任何*网络分区*故障的时候，仍然需要保证对外提供一致性和高可用性服务，除非是整个网络环境的故障。*网络分区*指不同子网络之间出现无法联通的情况，但子网络内正常，导致网络环境被切分成若干孤立区域。

| 放弃其中之一 | 说明 |
| :---:| :---: |
| 放弃P | 一种较为简单的方法是把所有的数据都放到一个节点上，同时也放弃了可扩展性 |
| 放弃A | 一旦遇到网络分区或其他故障时服务需要停止一段时间 |
| 放弃C | 放弃强一致性保留最终一致性 |

对于分布式系统来说，P(分区容错性)是一个基本的要求，因此根据业务点一般在C和A直接寻求平衡。

#### BASE

Basically Available（基本可用）、Soft state（软状态）、Eventually consistent(最终一致性)。是对CAP中一致性和可用性权衡的结果。

##### 基本可用

允许损失部分可用性，比如响应时间延长或功能降级。

##### 弱状态

允许不会影响系统整体可用性的数据中间状态，因为需要在不同节点之间进行数据同步。

##### 最终一致性

系统中的数据副本能够最终达到一致状态

+ 因果一致性，具有因果关系的进程A和进程B，进程B的读写一定在A之后。
+ 读自己所写，进程A总能读到自己更新后的数据。（不会读到数据副本中的旧值）
+ 回话一致性，总能在同一个会话中满足一致性
+ 单调读一致性，如果一个进程从系统中读取一个数据项的值后，系统后续不应该再返回旧值
+ 单调写一致性，保证同一个进程的写操作顺序执行

# 一致性协议

2PC、3PC、Paxos。2PC和3PC使用一个协调者来调度参与者进行事务提交和回滚。

## 2PC

使分布式事务保证原子性和一致性。

### 阶段一：提交事务请求

1. 事务询问，协调者向所有参与者发送事务内容，询问是否可以执行提交操作，并开始等待参与者响应
2. 执行事务，各参与者执行事务，并将Undo和Redo信息记入事务日志
3. 参与者向协调者反馈事务询问的响应

### 阶段二：执行事务提交

#### 执行事务提交

1. 发送提交请求，协调者向所有参与者发出Commit请求
2. 事务提交，参与者执行Commit请求，并释放资源
3. 反馈事务提交结果，参与者向协调者发送Ack消息
4. 完成事务，协调者收到所有Ack消息后完成事务

#### 中断事务

1. 发送回滚请求，协调者向所有参与者发送Rollback请求。
2. 事务回滚，参与者利用阶段一记录的Undo信息进行回滚，并释放资源
3. 反馈事务回滚结果，参与者完成回滚向协调者发送Ack消息
4. 中断事务，协调者收到所有Ack消息后完成事务中断

![2PC事务提交](/assets/images/994291e1-a6d5-4cbd-93bd-e942b8528ac5.png)

![2PC事务中断](/assets/images/f318aacc-57b2-44ab-bcfc-5d066b979125.png)

优点：原理简单，实现方便

缺点：

+ 同步阻塞，各阶段参与者都需要等待其他参与者响应，会极大限制分布式系统性能
+ 单点问题，协调者是个单点，如果协调者在阶段二出现问题，参与者无法释放资源以及完成事务
+ 脑裂，数据不一致，阶段二执行事务提交时，如果发生局部网络异常或协调者崩溃，收到Commit请求的参与者和未收到请求的将出现数据不一致
+ 太过保守，协调者进行事务提交询问过程中无法或者参与者响应，只能依靠自身超时机制判断是否中断事务。没有较为完善的容错机制，失败率高

## 3PC

将3PC的提交事务请求过程一分为二，CanCommit、PreCommit、do Commit三个阶段。

![3PC协议流程](/assets/images/1d96cc75-9cb4-4f05-af23-5264e7dab6bd.png)

### 阶段一：CanCommit

1. 事务询问，协调者向参与者询问是否可以执行事务提交，并等待响应
2. 参与者向协调者反馈响应

### 阶段二：PreCommit

根据阶段一的响应

#### 执行事务预提交

1. 发送预提交请求，协调者向参与者发送PreCommit请求，进入Prepared阶段
2. 事务预提交，参与者收到PreCommit请求后执行事务提交，并记录Undo和Redo信息到事务日志
3. 参与者反馈事务执行响应，同时等待最终指令：commit或abort
   

#### 中断事务

1. 协调者向参与者发送abort请求
2. 参与者收到abort请求或者等待超时，中断事务

### 阶段三：doCommit

#### 执行事务提交

1. 协调者向参与者发送doCommit请求
2. 参与者收到doCommit请求提交事务并释放资源
3. 参与者向协调者反馈Ack消息
4. 完成事务

#### 中断事务

1. 协调者向参与者发送abort请求
2. 参与者收到abort请求利用Undo信息执行回滚并释放资源
3. 参与者向协调者反馈Ack消息
4. 协调者收到所有Ack消息后完成事务中断

在阶段三协调者可能会出现问题或者协调者和参与者直接网络故障，参与者会在等待超时后执行事务提交

优点：降低了参与者的阻塞范围，并能出现单点故障后继续达成一致

缺点：参与者接收到preCommit命令后如果出现网络分区，该参与者会执行事务提交，会导致数据不一致

## Paxos算法

基于消息传递且高度容错的一致性算法。Paxos算法保证在分布式系统内被提出的提案中只有唯一的一个有效且被大部分节点认可和获取。在该算法中有三种参与者角色：Proposer、Acceptor、Learner。该算法面对的问题是所有参与者都以任意的不确定的状态运行，且参与者之间的通信也得不到保证。

### 提案的选定

为了避免Accpetor单点问题，该算法允许过半数的Acceptor同意的提案被选定。其中每个Acceptor最多只能批准一个提案。

### 推导过程

通过反向推导P2c、P2b、P2a、P2，然后通过P2和P1保证一致性。

#### P1：一个Acceptor必须批准它收到的第一个提案

##### 存在的问题

如果多个Proposer提出的提案被多个Acceptor批准，且每个Acceptor都批准了一个不同的提案。或者由于节点故障剩下的节点恰好为偶数。就无法选出提案

![每个Acceptor批准不同的提案](/assets/images/5048cc0a-58c4-498d-b520-58d9898a0f37.png)

![不同的提案被相同数量的Acceptor批准](/assets/images/979c8e05-b4d9-493c-8bd4-73cd3571dfea.png)

##### 解决方案

一个提案需要被半数以上Acceptor批准，所以一个Acceptor可以批准不止一个提案。因此引入一个全局编号M来标识每一个被批准的提案编号。当一个编号M0，值为V0的提案被半数以上Acceptor批准后可以被选定。

#### P2：如果编号为M0、值为V0的提案被选定，那么所有被选定的提案，如果编号比M0高，其值必须是V0

因为一个提案要被选定，必须至少被一个Acceptor批准

#### P2a：如果编号为M0、值为V0的提案被选定，那么所有被Acceptor批准的提案，如果编号比M0高，其值必须是V0

如果一个提案在某个Acceptor还未收到上一个提案时被选定，会产生一个被批准的值，且编号更高。

![一个提案在某个Acceptor还未收到上一个提案时被选定](/assets/images/5e9d7edc-7657-4bf2-8321-2ffd91ea6bb8.png)

#### P2b：如果一个值为V0提案被选定后，那么之后任何Proposer产生的编号更高的提案值必须为V0

因为M0已经被选定，所以肯定存在一个超过半数的Acceptor集合C，都批准了该提案。

因为任何半数以上的Acceptor集合S，都至少包含集合C中的一个成员，因此保证P2c即可满足P2b

#### P2c：对于被提出的提案Mn和Vn，存在集合S满足S中不存在任何批准过编号小于Mn的提案的Acceptor，或者S中所有Acceptor批准过得编号小于Mn的提案，其中编号最大的提案值也为Vn。

当M0，V0被选定的情况下，证明在P2C的前提下对于所有的[Mn，Vn]，存在Vn=V0。

（太绕，暂且留坑）

### Proposer生成提案

Proposer向Acceptor集合提出Prepare请求提案Mn，等待如下回应：

如果Acceptor没有批准过提案，Acceptor不再批准任何编号小于Mn的提案；否则返回已经批准过得提案中编号最大的提案的值。

如果Proposer收到半数以上Acceptor响应结果，就可以产生Mn，Vn提案。Vn是所有响应中编号最大的值或者新的值（如果Acceptor没有响应过提案）。

确定提案后Proposer再次向否个Acceptor集合发送提案以获得Accept请求。


### Acceptor批准提案

Acceptor可以在任何时候响应一个Prepare请求。

在不违背现有承诺的情况下可以响应Accept请求。

### 算法优化

如果一个Acceptor已经响应了Mn的Prepare请求，那么它可以忽略编号小于Mn的Prepare请求。也可以忽略已经批准过得提案的Prepare请求。

### 结果

概括为两个阶段的提交过程

#### 阶段一

Proposer向超过半数的Acceptor集合发送编号Mn的Prepare请求

Acceptor向Proposer反馈已经响应过Prepare请求的编号最大的值，并且不再批准编号小于Mn的提案

#### 阶段二

如果Proposer收到半数以上的Acceptor响应，那么它可以发出Mn，Vn的提案的Accept请求。Vn的值是响应中编号最大的值或者任意值（如果Acceptor没有响应过提案）。

如果Acceptor尚未对编号大于Mn的Prepare请求作出响应，那么它可以通过Mn的Accept请求