---
title: C++ Primer Plus
categories:
- c++
description: 
permalink: "/posts/cplusplus-primer-plus"
excerpt: C++是在C语言基础上开发的一种集面向对象编程、泛型编程和过程化编程于一体的编程语言，是C语言的超集。介绍C++程序的运行方式、基本数据类型、复合数据类型、循环和关系表达式、分支语句和逻辑运算符、函数重载和函数模板、内存模型和名称空间、类的设计和使用、多态、虚函数、动态内存分配、继承、代码重用、友元、异常处理技术、 string类和标准模板库、输入/输出、C++11新增功能等内容。
---

# C++简介

C++融合了3种不同的编程方式：C语言代表的过程性语言、C++在C语言基础上添加的类代表的面向对象语言、C+模板支持的泛型编程。一般来说，计算机语言要处理两个概念数据和算法。数据是程序使用和处理的信息，而算法是程序使用的方法。C语言是过程性（ procedural）语言，强调的是算，OOP强调的是数据。泛型强调独立于特定的数据类型。

名称C++来自C语言中的递增运算符++,表明它是C的补充版本。C提供了低级硬件访问，OOP提供了高级抽象。

程序如何运行：

1. 编写代码
2. 编译源代码，将源代码翻译为主机使用的机器语言，编译后就是目标代码
3. 将目标代码与其他代码链接起来

![编程步骤](/assets/images/cplusplus-primer-plus/编译步骤.png)

## 编译和连接

最初使用UNIX命令`CC`调用`cfront`编译器，将C++源代码翻译成C源代码，然后使用个标准C编译器对其进行编译。这种方法简化了向C的领域引入C++的过程。Linux系统中常用的是`g++`。Mac OS X系统中是`clang`。

+ Compile 通常意味着对当前打开的文件中的代码进行编译。
+ Build和Make通常意味着编译项目中所有源代码文件的代码。这通常是一个递增过程，也就是说，如果项目包含3个文件，而只有其中一个文件被修改，则只重新编译该文件。
+ Build All通常意味着重新编译所有的源代码文件
+ Link意味着将编译后的源代码与所需的库代码组合起来
+ Run或 Execute意味着运行程序。通常，如果您还没有执行前面的步骤，Run将在运行程序之前完成这些步骤
+ Debug意味着以步进方式执行程序。
+ 编译器可能让您选择要生成调试版还是发布版。调试版包含额外的代码，这会增大程序、降低执行速度，但可提供详细的调试信息。

## C++预处理器和头文件

C++引用的头文件由预处理在被编译之前添加到代码和程序中。

## 头文件名

C语言的头文件名由`.h`结尾，C++新风格的头文件没有扩展名。C++兼容C的头文件，同时C++重构C语言版本的头文件以`c`开头没有扩展名，如`cmath`。

## 名称空间

为了避免多厂商实现的同一个接口在使用时发生冲突，引入了名称空间概念。语法是`namespace::method`，如果`std::cout`。如果要省去每个方法都表明名称空间，可以使用`using namespace std`，如果只想生效部分方法，可以针对每个方法使用`using std::cout`，此后在使用`cout`方法时无需指定空间。可以在类上使用，也可以在方法中使用。

# 处理数据

## 字面量进制表示

如果第一位为1~9,则基数为10(十进制)；因此93是以10为基数的。如果第一位是0,第二位为1~7,则基数为八进制）；因此042的基数是8，它相当于十进制数34。如果前两位为0x或0X，则基数为16(十六进制)。

# 复合类型

## 数组初始化方法

``` c++
int array[4]={1,2,3,4};
int array[4];
int array[4] {1,2,3,4};
int array[4] {};
```

## 字符串string、char数组

``` c++
char name[10]="QuanLi";
char name[]="QuanLi";
```

c++98添加了`string`类。需要引用`#include <string>`。且其在`std`名称空间中，需要声明空间。`string`类相关的操作方法声明在`<cstring>`头文件中。

## 结构变量struct

声明自己的结构变量：

``` c++
struct persion  //在c++中，struct关键字可以省略
{
    string name;
    int age;
};

persion quanli={ "quanli", 25 };
persion list={
    {"leezw",25},
    {"quanli",25}
};
```

可以使用成员运算符`.`来访问各个成员，同样`.`也用来访问成员方法。

## 共用体union

结构体可以存储一组对象结构，共用体只能存储声明的其中一种变量，常用于节省空间。

```c++
/*只能存储一个int值或者一个long值*/
union ID{
    int int_val;
    long long_val;
}
```

用在结构体中是可以省略名称，则访问时可以省略一次成员访问：

```c++
struct product{
    union{
        int int_id;
        long long_id;
    }
} a_product;
a_product.int_id; //或a_product.long_id。
```

## 枚举enum

``` c++
enum colors {red,black,yellow};
colors red_color=red;
```
## 指针和自由存储空间

+ 指针声明`int * p`。
+ 取址运算符`&`，`p = &int_val`。
+ 取值符号`*`，`*p //int_val`。

使用指针可以在运行时分配内存，可以使用C语言的语法`malloc()`来分配内存，可以使用c++的语法`new`来分配内存`int * p = new int`。使用`delete`来释放内存`delete p`，但是同一个指针只可以调用一次。

数组指针的创建和使用：

```c++
int * array=new int [10];
delete [] array;
```

## 自动存储、静态存储和动态存储

1. 函数内的变量在函数调用是产生，结束后回收，是自动存储
2. 在函数外面定义或使用static定义的变量在整个程序运行期间都存在，是静态存储
3. 使用new生成delete释放的是动态存储

## 数组的替代品

模板类vector(c++98)：
``` c++
#include <vector>
using namespace std;
vector<int> a(3);
```

模板类array(c++11):
```c++
#include <array>
using namespace std;
array<int,5> a;
```

array和数组存储在栈中，而vector存储在堆中。

# 控制语句

## 基于范围的for循环(c++11)

```c++
int a[]{4,5,22};
for(int i:a){};
for(int i:{1,3,5}){};
```

## 逻辑运算符

`&& || !`逻辑运算符可以使用`and or not`代替，但是在C语言中需要引入`iso646.h`头文件，C++中可以直接使用。

# 函数

## 函数指针

+ 函数名既函数地址，传递函数`process(function)`。
+ 声明函数指针`int pow(int)`的指针声明方式为`int (*pf)(int)`
+ 使用函数指针调用函数`pow(2)`等同于`(*pf)(2)`等同于`pf(2)`
+ 同样可以使用`auto`功能，例如声明`int pow(2)`的函数指针`auto pf=pow`
+ 可使用`typedef`进行声明简化:
``` c++
typedef int (*intf)(int);
intf pf;
```

## 内联函数

声明函数时前面加上`inline`。和宏不同的是，宏只是简单的文本替换。而内联函数会有参数传递过程，特别表现在调用时使用`++`或`--`运算符时的表现。

## 引用变量

运算符`&`，用法`int & ref=val`变量的别名。引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是其副本。这样除指针之外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计类来说，引用也是必不可少的。

函数声明引用变量参数的方法：
```c++
int & method(int &a); //接收引用变量并返回引用变量
method(int_val); //调用声明了引用变量参数的方法
```

如果实参与引用参数不匹配，C++将生成临时变量。当前，仅当参数为`const`引用时，C+才允许这样做，如果引用参数是 `const`，则编译器将在下面两种情况下生成临时变量：
+ 实参的类型正确，但是匿名变量
+ 实参的类型不正确，但可以转换为正确的类型

将引用参数使用`const`修饰声明为常量数据的引用的理由有三个
+ 使用 `const`可以避免无意中修改数据的编程错误
+ 使用 `const`使函数能够处理 `const`和非 `const`实参，否则将只能接受非 `const`数据
+ 使用 `const`引用使函数能够正确生成并使用临时变量

返回引用而不是值，可以只传递引用，从而避免一次值拷贝。但是不要返回方法内临时变量的引用，方法执行完后会被销毁。返回引用也可以使用`const`修饰，这样在调用方法位置不能对返回值进行修改。

## 模板函数

```c++
template <typename T> //typename可以替换为class，class用于向后兼容。建议使用typename
void swap(T &a,T &b){};
```

当需要模板函数适应特殊类型变量时，使用显示具体化。对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载版本。这样当调用模板方法，且匹配到显示的类型时将调用显示模板方法：
```c++
template <> void swap<int>(int &a,int &b){};
```

显示实例化和显示具体化的语法相近`template void swap<int>(int &a,int &b){}`，告诉编译器直接实例化一个方法，而不是在运行时通过模板实例化。

## 编译器选择使用哪个函数版

1. 创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数。
2. 使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包括实参类型与相应的形参类型完全匹配的情况。例如，使用float参数的函数调用可以将该参数转换为 double，从而与 double形参匹配，而模板可以为oat生成一个实例。
3. 确定是否有最佳的可行函数。如果有，则使用它，否则该函数调用出错

# 内存模型和名称空间

