---
title: C++ Primer Plus
categories:
- c++
description: 
permalink: "/posts/cplusplus-primer-plus"
excerpt: C++是在C语言基础上开发的一种集面向对象编程、泛型编程和过程化编程于一体的编程语言，是C语言的超集。介绍C++程序的运行方式、基本数据类型、复合数据类型、循环和关系表达式、分支语句和逻辑运算符、函数重载和函数模板、内存模型和名称空间、类的设计和使用、多态、虚函数、动态内存分配、继承、代码重用、友元、异常处理技术、 string类和标准模板库、输入/输出、C++11新增功能等内容。
---

## C++简介

C++融合了3种不同的编程方式：C语言代表的过程性语言、C++在C语言基础上添加的类代表的面向对象语言、C+模板支持的泛型编程。一般来说，计算机语言要处理两个概念数据和算法。数据是程序使用和处理的信息，而算法是程序使用的方法。C语言是过程性（ procedural）语言，强调的是算，OOP强调的是数据。泛型强调独立于特定的数据类型。

名称C++来自C语言中的递增运算符++,表明它是C的补充版本。C提供了低级硬件访问，OOP提供了高级抽象。

程序如何运行：

1. 编写代码
2. 编译源代码，将源代码翻译为主机使用的机器语言，编译后就是目标代码
3. 将目标代码与其他代码链接起来

![编程步骤](/assets/images/cplusplus-primer-plus/编译步骤.png)

### 编译和连接

最初使用UNIX命令`CC`调用`cfront`编译器，将C++源代码翻译成C源代码，然后使用个标准C编译器对其进行编译。这种方法简化了向C的领域引入C++的过程。Linux系统中常用的是`g++`。Mac OS X系统中是`clang`。

+ Compile 通常意味着对当前打开的文件中的代码进行编译。
+ Build和Make通常意味着编译项目中所有源代码文件的代码。这通常是一个递增过程，也就是说，如果项目包含3个文件，而只有其中一个文件被修改，则只重新编译该文件。
+ Build All通常意味着重新编译所有的源代码文件
+ Link意味着将编译后的源代码与所需的库代码组合起来
+ Run或 Execute意味着运行程序。通常，如果您还没有执行前面的步骤，Run将在运行程序之前完成这些步骤
+ Debug意味着以步进方式执行程序。
+ 编译器可能让您选择要生成调试版还是发布版。调试版包含额外的代码，这会增大程序、降低执行速度，但可提供详细的调试信息。

### C++预处理器和头文件

C++引用的头文件由预处理在被编译之前添加到代码和程序中。

### 头文件名

C语言的头文件名由`.h`结尾，C++新风格的头文件没有扩展名。C++兼容C的头文件，同时C++重构C语言版本的头文件以`c`开头没有扩展名，如`cmath`。

### 名称空间

为了避免多厂商实现的同一个接口在使用时发生冲突，引入了名称空间概念。语法是`namespace::method`，如果`std::cout`。如果要省去每个方法都表明名称空间，可以使用`using namespace std`，如果只想生效部分方法，可以针对每个方法使用`using std::cout`，此后在使用`cout`方法时无需指定空间。可以在类上使用，也可以在方法中使用。

## 处理数据

### 字面量进制表示

如果第一位为1~9,则基数为10(十进制)；因此93是以10为基数的。如果第一位是0,第二位为1~7,则基数为八进制）；因此042的基数是8，它相当于十进制数34。如果前两位为0x或0X，则基数为16(十六进制)。

## 复合类型

### 数组初始化方法

``` c++
int array[4]={1,2,3,4};
int array[4];
int array[4] {1,2,3,4};
int array[4] {};
```

### 字符串string、char数组

``` c++
char name[10]="QuanLi";
char name[]="QuanLi";
```

c++98添加了`string`类。需要引用`#include <string>`。且其在`std`名称空间中，需要声明空间。`string`类相关的操作方法声明在`<cstring>`头文件中。

### 结构变量struct

声明自己的结构变量：

``` c++
struct persion  //在c++中，struct关键字可以省略
{
    string name;
    int age;
};

persion quanli={ "quanli", 25 };
persion list={
    {"leezw",25},
    {"quanli",25}
};
```

可以使用成员运算符`.`来访问各个成员，同样`.`也用来访问成员方法。

### 共用体union

结构体可以存储一组对象结构，共用体只能存储声明的其中一种变量，常用于节省空间。

```c++
/*只能存储一个int值或者一个long值*/
union ID{
    int int_val;
    long long_val;
}
```

用在结构体中是可以省略名称，则访问时可以省略一次成员访问：

```c++
struct product{
    union{
        int int_id;
        long long_id;
    }
} a_product;
a_product.int_id; //或a_product.long_id。
```

### 枚举enum

``` c++
enum colors {red,black,yellow};
colors red_color=red;
```
### 指针和自由存储空间

+ 指针声明`int * p`。
+ 取址运算符`&`，`p = &int_val`。
+ 取值符号`*`，`*p //int_val`。

使用指针可以在运行时分配内存，可以使用C语言的语法`malloc()`来分配内存，可以使用c++的语法`new`来分配内存`int * p = new int`。使用`delete`来释放内存`delete p`，但是同一个指针只可以调用一次。

数组指针的创建和使用：

```c++
int * array=new int [10];
delete [] array;
```

### 自动存储、静态存储和动态存储

1. 函数内的变量在函数调用是产生，结束后回收，是自动存储
2. 在函数外面定义或使用static定义的变量在整个程序运行期间都存在，是静态存储
3. 使用new生成delete释放的是动态存储

### 数组的替代品

模板类vector(c++98)：
``` c++
##include <vector>
using namespace std;
vector<int> a(3);
```

模板类array(c++11):
```c++
##include <array>
using namespace std;
array<int,5> a;
```

array和数组存储在栈中，而vector存储在堆中。

## 控制语句

### 基于范围的for循环(c++11)

```c++
int a[]{4,5,22};
for(int i:a){};
for(int i:{1,3,5}){};
```

### 逻辑运算符

`&& || !`逻辑运算符可以使用`and or not`代替，但是在C语言中需要引入`iso646.h`头文件，C++中可以直接使用。

## 函数

### 函数指针

+ 函数名既函数地址，传递函数`process(function)`。
+ 声明函数指针`int pow(int)`的指针声明方式为`int (*pf)(int)`
+ 使用函数指针调用函数`pow(2)`等同于`(*pf)(2)`等同于`pf(2)`
+ 同样可以使用`auto`功能，例如声明`int pow(2)`的函数指针`auto pf=pow`
+ 可使用`typedef`进行声明简化:
``` c++
typedef int (*intf)(int);
intf pf;
```

### 内联函数

声明函数时前面加上`inline`。和宏不同的是，宏只是简单的文本替换。而内联函数会有参数传递过程，特别表现在调用时使用`++`或`--`运算符时的表现。

### 引用变量

运算符`&`，用法`int & ref=val`变量的别名。引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是其副本。这样除指针之外，引用也为函数处理大型结构提供了一种非常方便的途径，同时对于设计类来说，引用也是必不可少的。

函数声明引用变量参数的方法：
```c++
int & method(int &a); //接收引用变量并返回引用变量
method(int_val); //调用声明了引用变量参数的方法
```

如果实参与引用参数不匹配，C++将生成临时变量。当前，仅当参数为`const`引用时，C+才允许这样做，如果引用参数是 `const`，则编译器将在下面两种情况下生成临时变量：
+ 实参的类型正确，但是匿名变量
+ 实参的类型不正确，但可以转换为正确的类型

将引用参数使用`const`修饰声明为常量数据的引用的理由有三个
+ 使用 `const`可以避免无意中修改数据的编程错误
+ 使用 `const`使函数能够处理 `const`和非 `const`实参，否则将只能接受非 `const`数据
+ 使用 `const`引用使函数能够正确生成并使用临时变量

返回引用而不是值，可以只传递引用，从而避免一次值拷贝。但是不要返回方法内临时变量的引用，方法执行完后会被销毁。返回引用也可以使用`const`修饰，这样在调用方法位置不能对返回值进行修改。

函数`const Foo & fun(const Foo & f) const;`隐式访问一个对象(this)，显示访问另一个对象(f)，并返回一个对象的引用。括号中的 const表明，该函数不会修改被显式地访问的对象：而括号后的 const表明，该函数不会修改被隐式地访问的对象。由于该函数返回了两个 const对象之一的引用，因此返回类型也应为 const引用。

### 模板函数

```c++
template <typename T> //typename可以替换为class，class用于向后兼容。建议使用typename
void swap(T &a,T &b){};
```

当需要模板函数适应特殊类型变量时，使用显示具体化。对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载版本。这样当调用模板方法，且匹配到显示的类型时将调用显示模板方法：
```c++
template <> void swap<int>(int &a,int &b){};
```

显示实例化和显示具体化的语法相近`template void swap<int>(int &a,int &b){}`，告诉编译器直接实例化一个方法，而不是在运行时通过模板实例化。

### 编译器选择使用哪个函数版

1. 创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数。
2. 使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包括实参类型与相应的形参类型完全匹配的情况。例如，使用float参数的函数调用可以将该参数转换为 double，从而与 double形参匹配，而模板可以为oat生成一个实例。
3. 确定是否有最佳的可行函数。如果有，则使用它，否则该函数调用出错

## 内存模型和名称空间

### 存储说明符和cv-限定符

存储说明符：
+ register （用于在声明中指示寄在器存储）
+ static
+ extern（引用声明，即声明引用在其他地方定义的变量）
+ thread_loacl（之于线程，犹如常规静态变量之于整个程序）
+ mutable（即使结构（或类）变量为 const，其某个成员也可以被修改）

cv-限定符：
+ const（内存被初始化后，程序便不能再对它进行修改）
+ volatile（即使程序代码没有对内存单元进行修改，其值也可能发生变化）

static使用：

+ 在函数外部没有static修饰的变量可在程序的其他文件中使用
+ 在函数外部有static修饰的变量可在程序的引用它的文件中使用
+ 在函数内部有static修饰的变量只能在函数内部使用，但是他是全局静态的
+ 用于方法时，该函数只在文件中可见，将覆盖外部定义

### 定位new运算符

new可以指定地址位置，这时将不受delete控制。

```c++
char buffer1[50];
char buffer2[500];
a_struct *p1 = new (buffer1) a_struct;
int *p2 = new (buffer2) int[20];
```
## 名称空间

C++中的名称空间除了全局和方法内，还可以自定义名称空间。名称空间可以是全局的也可以位于另一个名称空间中(嵌套：OuterNameSpace::InnerNameSpace::field)及在另一个名称空间中使用，但不能位于代码块中。

```c++
// 声明一个名称空间
namespace MyNameSpace{
    double filed1;
    void method1();
}
// 向名称空间中添加名称
namespace MyNameSpace{
    struct struct1{ ... }
}
// 对名称空间中的方法原型进行实现
namespace MyNameSpce{
    void method1()
    {
        ...
    }
}
```

using 声明(using MyNameSpace::field1)将名称添加到using所属的声明区域中，以便于不用每次都使用空间限定符`::`；using编译指令(using namespace MyNameSpace)使空间中所有名称都可用。

当局部变量隐藏同名的全局变量时，如果想要调用全局变量可以使用不带命名空间的限定符`::var`。命令空间可以创建别名`namespace MNS = MyNameSpace`


## 对象

### 构造函数和析构函数

+ 构造函数结构`Foo(const string & f1,long f2=0, double f3 = 0.0);`
+ 使用构造函数创建并初始化对象`Foo *foo = new Foo("foo",19,17.0);`
+ 使用构造函数初始化对象`Foo foo = Foo("foo",1,2.0);`或`Foo foo("foo",1,2.0);`
+ 使用列表初始化对象`Foo foo = {"foo",1,2.0};`
+ 使用列表初始化对象`Foo foo {"foo",1,2.0};`
+ 如果没有提供显示构造函数，则自动生成默认构造函数。默认构造函数可以是没有参数的，也可以是所有参数都有默认值的，但是不能两种同时存在
+ 析构函数`~Foo();`



## 使用类

### 运算符重载

运算符重载分为成员函数重载和非成员函数重载，需要使用成员函数访问符`object.method()`访问的是成员函数，不需要的是非成员函数。`operator*op*(arglist)`重载运算符，比如`operator+()`重载+运算符。运算符重载只能重载已有的运算符，不能创造新的运算符。不能违反运算符原来的语法规则和优先级。

`B + 2.7`将调用B重载运算符的成员函数，但是反过来`2.7 + B`将行不通，这时需要使用友元来重载`operator+(double d,const B & b)`

### 友元

+ 友元函数
+ 友元类
+ 友元成员函数

创建友元函数需要将函数原型放在类声明中，并在原型声明前加关键字friend `friend Foo operator*(int m,const Foo & f);`。这意味着虽然函数是在类声明中声明的，但不是成员函数；虽然不是成员函数但与成员函数的访问权限相同。

### 类的自动类型转换和强制类型转换

如果一个类有只有一个参数的构造函数，或构造函数中除了第一个参数其他参数都有默认值，则可以将参数类型显示或隐式转化为该类对象。这将生效与赋值、函数调用、传参、返回值类型中。`Foo(int i,double d=1.0);`

在构造函数前面加上`explicit`可以关闭改类改构造函数类型的隐式类型转换，但仍可以使用强制类型转换。`explicit Foo(int i,double d=1.0);`

构造函数可以实现类型转换，但是如果想要反向转换类型，就需要用到转换函数。转换函数的函数原型为`operator *typeName*();`。比如Foo转换成int类型就是`operator int();`。转换函数必须是类方法；不能指定返回类型（但是也要返回所需的值）；不能有参数。转换函数同样可以加`explicit`修饰禁止隐式转换。

## 类和动态内存分配

### 特殊成员函数

C++会自动生成一些类的成员函数：

+ 默认构造函数，如果没有定义构造函数
+ 默认析构函数，如果没有定义
+ 复制构造函数（函数原型`Foo(const Foo &);`），如果没有定义
+ 赋值运算符（函数原型`Foo & Foo::operator=(const Foo &);`），如果没有定义
+ 地址运算符，如果没有定义

### 在构造函数中使用new时应注意的事项

+ 如果有多个构造函数，则必须以相同的方式使用new，要么都带中括号，要么都不带。因为只能有一个析构函数，所有构造函数都必须与它兼容。
+ 应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象
+ 应定义一个赋值运算符，通过深度复制将一个对象赋值给另一个对象

### 返回对象的说明

1. 返回指向const对象的引用，返回引用可以提高效率避免对象复制
2. 返回指向非const对象的引用，常见于重载赋值运算符和<<运算符
3. 返回对象，函数中的局部变量会在函数结束后消失，需要返回一个新对象
4. 返回const对象

### 使用指向对象的指针

对象中的new和delete：

+ 如果对象是动态变量，在程序块结束时将被销毁
+ 如果对象是静态变量（外部、静态、静态外部或来自名称空间），则在程序结束时将被销毁
+ 如果对象是用new创建，将在显示使用delete时被销毁

指向对象的指针：

+ 使用常规表示法来生命指向对象的指针`Foo * foo;`
+ 可以将指针初始化为指向已有的对象`Foo * foo1 = &foo2;`
+ 可以使用new来通过构造函数初始化指针`Foo * foo = new Foo();`
+ 使用`->`运算符来通过指针访问类方法
+ 对对象指针应用解除引用运算符`*`来获得对象

### 成员初始化列表

由于const和引用类型的对象必须在创建时进行初始化，所以在构造函数执行之前被创建，无法在构造函数中进行赋值。此时需要使用成员初始化列表语法：
```c++
Foo::Foo(int n,int m) :const_int_field(n),ref_int_field(m),another_const_field(1)
{
//...
}
```

+ 只能用于构造函数
+ 非静态const数据成员如果在构造函数中必须用初始化列表初始化
+ 引用数据成员如果在构造函数中必须用初始化列表初始化
+ 非const数据成员也可以使用初始化列表，但是没必要
+ 初始化列表语法的赋值可以覆盖直接赋值`const int a=1;`

TODO 13