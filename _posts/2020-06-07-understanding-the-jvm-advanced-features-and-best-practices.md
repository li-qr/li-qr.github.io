---
title: 深入理解Java虚拟机——JVM高级特性与最佳实践
categories:
- JAVA
- JVM
description: 深入理解Java虚拟机——JVM高级特性与最佳实践摘要
permalink: "/posts/understanding-the-jvm-advanced-features-and-best-practices"
excerpt: 序员可以把主要精力放在具体业务逻辑，而不是放在保障物理硬件的兼容性上。通常情况下，一个程序员只要了解了必要的Java类库API、Java语法，学习适当的第三方开发框架，就已经基本满足日常开发的需要了。虚拟机会在用户不知不觉中完成对硬件平台的兼容及对内存等资源的管理工作。如果开发人员不了解虚拟机诸多技术特性的运行原理，就无法写出最适合虚拟机运行和自优化的代码。但是，如果用于生产开发，尤其是大规模的、企业级的生产开发，就迫切需要开发人员中至少有一部分人对虚拟机的特性及调节方法具有很清晰的认识。所以在Java开发体系中，对架构师、系统调优师、高级程序员等角色的需求一直都非常大。学习虚拟机中各种自动运作特性的原理也成为Java程序员成长路上最终必然会接触到的一课。
---

# Java内存区域与内存溢出异常

## 概述

因为Java程序员把控制内存的权利交给了Java虚拟机，一旦出现内存泄露和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误、修正问题将成为一项异常艰难的工作。

## 运行时数据区域

这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域是依赖用户线程的启动和结束而建立和销毁。

![Java虚拟机运行时数据区](/assets/images/understanding-the-jvm-advanced-features-and-best-practices/2c4c9d28-3e69-4d0e-94c6-2e3e71cf6f2b.png)

### 程序计数器

程序计数器(Progam Counter Register)是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

由于Java虛拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(对于多核处理器来说是一个内核)都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有"的内存。

如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虛拟机字节码指令的地址;如果正在执行的是本地(Native) 方法，这个计数器值则应为空(Undefined) 。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。

### Java虚拟机栈

线程私有，生命周期与线程相同。栈描述的是Java方法执行的线程内存模型，由于存储局部变量表、操作数栈、动态链接、方法出口等信息。方法的调用和执行对应栈帧的入栈和出栈。

局部变量表存放了编译期可知的各种Java虚拟机基本数据类型、对象引用和returnAddress类型（指向一条字节码指令地址）

这些数据类型以局部变量槽（Slot）来表示，64位的long和double占用两个槽，其他类型占用一个槽。局部变量表所需的空间在编译期完成分配，进入方法时分配的空间大小（槽的数量）确定运行时不会改变。

《Java虚拟机规范》中规定了内存区域两种异常情况：如果线程请求的栈深度大于虚拟机允许深度，抛出StackOverflowError；对于非HotSpot虚拟机，如果栈容量扩展时没有足够空间抛出OutOfMemoryError。HotSpot无法扩容，所以在栈空间申请时可能会抛出OOM异常。

### 本地方法栈

执行本地方法（Native）的栈空间。同样存在栈溢出和OOM异常。

### Java堆

线程共享区域，启动时创建。用于存放对象实例。由GC管理。从GC的角度看，在G1之前大部分GC都是基于分代收集理论设计，因此堆会被垃圾回收器分为新生代（Eden、Survivor）、老年代、永久代（方法区）等区域。但是G1开始不再对堆进行分代回收，也就不再划分分代区域。

堆也会划出多个线程私有的分配缓冲区（Thread Local Allocation Buffer TLAB）来提升对象分配时的效率。《规范》中没有规定堆的物理空间连续性，只规定了逻辑空间上的连续性。而虚拟机的实现可能要求大对象请求连续的内存空间。堆空间不够时会抛出OOM异常。《规范》中没有规定该区域是固定大小还是可伸缩。

### 方法区

线程共享，存储已经被虚拟机加载的类型信息、常量、静态变量、JIT代码缓存等数据。《规范》中描述方法区是堆的一部分，但方法区有个别名叫“非堆”。仅HotSpot使用永久代来实现方法区，以便垃圾回收器可以管理这部分内存省去专门编写方法区内存管理的工作。其他虚拟机不存在方法区概念。HotSpot在JDK8后完全废除永久代的概念，改用本地内存中实现的元空间来替代。《规范》中没有规定方法区物理内存连续性和空间是否固定，也没有规定必须实现垃圾回收。方法区内存不足时会抛OOM异常。

### 运行时常量池

是方法区的一部分。Class文件中的常量池表(Constant Pool Table)，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。该区域在《规范》中没有细节要求。并且常量可以动态产生放入常量池。常量池内存不足时会OOM异常。

### 直接内存

直接内存不是虚拟机运行时数据区的内容，也不是《规范》中定义的区域，存在OOM异常。

在JDK 1.4中新加入了NIO (New Input/Output)类，引入了一种基于通道(Channel) 与缓冲区( Buffr)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

## HotSpot虚拟机对象

### 对象的创建

当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。为对象分配空间的方法由GC是否进行碎片整理决定：对于Serial、ParNew等进行碎片整理的GC使用指针碰撞的方式（移动空闲空间指针）；对于CMS等使用空间列表来分配（存储剩余空闲空间列表）。但是CMS的实现中，为了能在多数情况下快速分配，设计了Linear Allocation Buffer分配缓冲区，通过空闲列表获取一大块分配缓冲区后使用指针碰撞方式分配对象内存。

有两种方式解决线程分配时的线程安全性，一种采用CAS失败重试方式保证空间指针移动与对象内存分配的原子性；一种是使用本地线程分配缓冲TLAB，优先在本地缓冲区分配内存，当本地缓冲区用完后同步锁定。

内存分配完成之后，虚拟机将分配到的内存空间(但不包括对象头)都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这也就是为什么int的默认值是0，boolean的默认值是false。

接下来，Java虚拟机对象头进行初始化。

至此对于虚拟机来说一个对象已经创建完成了。接下来是Java程序的对象创建。调用构造函数进行对象初始化。即Class文件中的<init>()方法。









# Java技术体系

Java程序设计语言、Java虚拟机、Java类库三部分统称为JDK。JCP官方所定义的Java技术体系包括了：

+ Java程序设计语言
+ 各种硬件平台上的Java虚拟机实现
+ Class文件格式
+ Java类库API
+ 第三方Java类库

![Java技术体系](/assets/images/understanding-the-jvm-advanced-features-and-best-practices/8f3089a1-3bad-4e66-ab81-b72bbc725839.png)

# Java虚拟机家族

1. 虚拟机始祖：Sun Classic/Exact VM，只能解释执行Java，或通过外挂即时编译器。并且两者冲突。
2. HotSpot VM，由Sun收购而来。拥有热点代码探测技术，通过执行计数器找到热点代码进行即时编译。和栈上替换编译(OSR)。
3. Mobile/Embedded VMs，Java ME产品线上的虚拟机。
4. BEA JRockit和IBM j9 VM。
5. Google Android Dalvik VM。
6. Microsoft JVM。
7. 专用硬件平台上的虚拟机及其他。

2018年Oracle Labs公开了Graal VM。号称Run Programs Faster Anywhere。除了可以运行JVM系语言，还可以运行C、C++等基于LLVM语言和JavaScript、Ruby、Python、R。Graal VM可以无额外开销的混合使用这些语言，支持不同语言混用接口。

# 新一代即时编译器

HotSpot,虚拟机中含有两个即时编译器，分别是编译耗时短但输出代码优化程度较低的客户端编译器(简称为C1)以及编译耗时长但输出代码优化质量也更高的服务端编译器(简称为C2)，通常它们会在分层编译机制下与解释器互相配合来共同构成HotSpot虚拟机的执行子系统。自JDK 10 起，HotSpot引入和Graal编译器。

# 向Native迈进

在未来微服务甚至无服务的趋势下，Java越来越显得臃肿和不适应。因为Java需要几百兆的JRE，以及预热才能达到快速运行。所以Java需要向提前编译迈进，但是提前编译就不能一次编写到处运行。直到Substrate VM的出现。

Subtrate VM是在Graal VM 0.20版本里新出现的一个极小型的运行时环境，包括了独立的异常处理、同步调度、线程管理、内存管理(垃圾收集)和JNI访问等组件，目标是代替HotSpot用来支持提前编译后的程序执行。它还包含了一个本地镜像的构造器(Native Image Generator)，用于为用户程序建立基于Substrate VM的本地运行时镜像。这个构造器采用指针分析(Points-To Analysis)技术，从用户提供的程序入口出发，搜索所有可达的代码。在搜索的同时，它还将执行初始化代码，并在最终生成可执行文件时，将已初始化的堆保存至一个堆快照之中。这样一来，Substrate VM就可以直接从目标程序开始运行，而无须重复进行Java虛拟机的初始化过程。但相应地，原理上也决定了Substrate VM必须要求目标程序是完全封闭的，即不能动态加载其他编译器不可知的代码和类库。基于这个假设，Substrate VM才能探索整个编译空间，并通过静态分析推算出所有虛方法调用的目标方法。Substrate VM带来的好处是能显著降低内存占用及启动时间。

# HotSpot

现在，HotSpot 虚拟机能够在编译时指定一系列特性开关，让编译输出的HotSpot虚拟机可以裁剪成不同的功能，譬如支持哪些编译器，支持哪些收集器，是否支持JFR、
AOT、CDS、NMT等都可以选择。能够实现这些功能特性的组合拆分，反映到源代码不仅仅是条件编译，更关键的是接口与实现的分离。

早期的HotSpot虛拟机为了提供监控、调试等不会在《Java虛 拟机规范》中约定的内部功能和数据，就曾开放过Java虛拟机信息监控接口(Java Vrtual M achine ProflerInterface，JVMPI) 与Java虛 拟机调试接口(Java Vrtual M achine Debug Interface, JVMDI)供运维和性能监控、IDE等外部工具使用。到了JDK 5时期，又抽象出了层次更高的Java虚拟机工具接口(Java Virtual Machine Tool Interface, JVMTI) 来为所有Java虛拟机相关的工具提供本地编程接口集合，到JDK 6时JVMTI就完全整合代替了JVMPI和JVMDI的作用。

在JDK 9时期，HotSpot虛拟机开放了Java语言级别的编译器接口B] (Java Vrtual M achine Compiler Interface, JVMCI) ，使得在Java虛拟机外部增加、替换即时编译器成为可能，这个改进实现起来并不费劲，但比起之前JVMPI、JVMDI和JVMTI却是更深层次的开放，它为不侵入HotSpot代码而增加或修改HotSpot虛拟机的固有功能逻辑提供了可行性。Graal编译器就是通过这个接口植入到HotSpot之中。

到了JDK 10，HotSpot又重构了Java虛拟机的垃圾收集器接口[4] (Java Vrtual M achine Compiler Interface)，统一了其内部各款垃圾收集器的公共行为。有了这个接口，才可能存在日后(今天尚未)某个版本中的CM S收集器退役，和JDK 12中Shenandoah这样由Oracle以外其他厂商领导开发的垃圾收集器进入HotSpot中的事情。如果未来这个接口完全开放的话，甚至有可能会出现其他独立于HotSpot的垃圾收集器实现。

