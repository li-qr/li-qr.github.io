---
title: 设计模式——可复用面向对象软件的基础
categories:
- 设计模式
description: 计模式——可复用面向对象软件的基础
permalink: "/posts/design-patterns-elements-of-reusable-object-oriented-softwar"
excerpt: 所有结构良好的面向对象软件体系结构中都包含了许多模式。设计模式可以使系统结构更加精巧、简洁和易于理解。
---

# 设计模式

## 创造型模式

+ **abstract factory**：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。(抽象工厂，对象)
+ **builder**：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。(生成器，对象)
+ **factory method**：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。使得一个类的实例化延迟到其子类。(工厂方法，类)
+ **prototype**：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。(原型，对象)
+ **singleton**：保证一个类仅有一个实例，并提供一个访问它的全局访问点。(单例，对象)

## 结构型模式

+ **adapter**：将一个类的接口转换成客户希望的另一个接口。使得原本由于接口不兼容而不能一起工作的类可以一起工作。(适配器,类)
+ **bridge**：将抽象部分与它的实现部分分离，使它们可以独立的变化。(桥接，对象)
+ **composite**：将对象组合成树形结构以表示“部分-整体”的层次结构。使得客户对单个对象和复合对象的使用具有一致性。(组成，对象)
+ **decorator**：动态地给一个对象添加一些额外的职责。就扩展功能而言，比生成子类的方式更灵活。(装饰，对象)
+ **facade**：为子系统中的一组接口提供一个一致的页面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。(外观，对象)
+ **flyweight**：运用共享技术有效地支持大量细粒度的对象。(享元，对象)
+ **proxy**：为其他对象提供一个代理以控制对这个对象的访问。(代理，对象)

## 行为模式

+ **chain of responsibility**：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。(责任链，对象)
+ **command**：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。(命令，对象)
+ **interpreter**：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。(解释器，对象)
+ **iterator**：提供一种方法顺序访问一个集合对象中各个元素，而又不暴露该对象的内部表示。(迭代器，类)
+ **mediator**：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。(中介者，对象)
+ **memento**：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象外保存这个状态。这样以后就可将该对象恢复到保存的状态。(备忘录，对象)
+ **observer**：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。(观察者，对象)
+ **state**：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎改变了他所属的类。(状态，对象)
+ **strategy**：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。此模式使得算法的变化可独立于它的客户。(策略，对象)
+ **template method**：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。(模板方法，类)
+ **visitor**：表示一个作用于某对象结构中的各元素的操作。他是你可以在不改变个元素的类的前提下定义作用于这些元素的新操作。(访问者，对象)

设计模式展示了如何使用面向对象的继承和实现、方法的重载和重写等基本技术，是对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述。设计模式包含四个基本要素：模式名称、问题、解决方案、效果。各个模式之间经常会捆绑使用(composite、iterator、visitor)或互相替代(prototype、abstract factory)或尽管意图不同，但产生的设计结果相似(composite、decorator)。它为我们使用的各种技术提供了标准的名称和定义。算法和数据结构会有其命名和分类，但我们很少为其他类型的模式命名。设计模式就为设计者们交流讨论，书写文档以及探索更多不同的设计提供了一套通用的设计词汇。同时提供了一些常见问题的解决方案。

开发可复用软件时不得不重新组织或重构软件系统。设计模式可以帮助减少重构工作。面向对象的软件生命周期可分为三个阶段：原型阶段、扩展阶段和巩固阶段。首先建立一个快速原型，在此基础上进行增量式修改直到满足基本需求，然后进入扩展阶段新的需求要求加入新的类和操作甚至整个类层次，软件的不断扩展使其变得膨胀臃肿难以进行进一步修改。该软件若要继续演化就必须进行重新组织，这个过程称为 *重构* 。框架常常在这个阶段出现。重构工作包括将类拆分为专用和通用构件，并使各个类的接口合理化。

好的设计者不仅知道哪些变化会促使重构，还要知道哪些类和对象结构能够避免重构，使得设计对需求的变化具有健壮性。对需求的彻底分析有助于突出易于发生变化的需求。设计模式可以尽量防止以后的重构。

# 创造型模式

## 简单工厂模式

简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式。


# 附录——词汇表

+ 抽象类（abstract class）    一种主要用于定义接口的类。抽象类中的部分或全部操作被延迟到子类中实现。抽象类不能实例化。
+ 抽象耦合（abstract coupling）    若类A维护了一个指向类B的引用，称A抽象耦合于B。因为A指向的是对象类型而不是对象实例。
+ 抽象操作（abstract operation）    一种声明了结构而没有实现的操作。比如 *纯虚成员函数* 。
+ 相识关系（acquaintance relationship）    如果一个类指向另一个类，则两个类之间有相识关系。
+ 聚合对象（aggregate object）    一种包含子对象的对象。这些子对象称为聚合对象的部分，而聚合对象对它们负责。
+ 聚合关系（aggregation relationship）    聚合对象与其部分之间的关系。类为其对象定义这种关系。
+ 黑箱复用（black-box reuse）    一种基于对象组合的复用方式。这些被组合的对象之间并不开放各自的内部细节。
+ 类（class）    类定义对象的接口个实现。规定对象的内部表示，定义对象可实施的操作。
+ 类图（class diagram）    类图描述类及其内部结构和操作，以及类间的静态关系。
+ 类操作（class operation）    以类而不是单独的对象为目标的操作。比如 *静态成员函数* 。
+ 具体类（concrete class）    不含抽象操作的类，可以实例化。
+ 构造器（constructor）    系统自动调用用来初始化新对象实例的操作。
+ 耦合（coupling）    软件构件之间相互依赖的程度。
+ 委托（delegation）    一个对象把发送给它的请求转发/委托为另一个对象。而受委托对象代表原对象执行请求操作。
+ 设计模式（design pattern）    针对面向对象系统中重复出现的设计问题，提出一个通用的设计方案，并予以系统化的命令和动机解释。它描述了问题、解决方案、在什么条件下使用该解决方案及其效果。它还给出了实现要点和实例。该解决方案是解决该问题的一组精心安排的通用的类和对象，再经定制和实现就可用来解决特定上下文的问题。
+ 析构器（destructor）    系统自动调用用来清理即将被删除的对象的操作。
+ 动态绑定（dynamic binding）    在运行时刻才将一个请求与一个对象及其一个操作关联起来。
+ 封装（encapsulation）    其结果是将对象的表示和实现隐藏起来。在对象之外，看不到其内部表示，也不能直接对其进行访问。操作是访问和修改对象表示的唯一途径。
+ 框架（framework）    一组相互协作的类，形成某类软件的一个可复用设计。框架将设计划分为一组抽象类，并定义它们各自的职责及相互之间的合作，以此来指到体系结构级的设计。开发者通过继承框架中的类和组合其实例来定制框架以生成特定的应用。
+ 友类（friend class）    A为B的友类，A对B中的操作和数据有与B本身一样的访问权限。
+ 继承（inheritance）    两个实体间的一种关系，其中一实体是基于另一个实体而定义的。子类继承父类的接口和实现，也叫派生类。类继承包含了接口继承和实现继承。接口继承以一个或多个已有接口为基础定义新的接口。
+ 实例变量（instance variable）    定义部分对象表示的数据。也叫 *数据成员* 。
+ 交互图（interaction diagram）    展示对象间请求流程的一种示意图。
+ 接口（inteface）    一个对象所有操作定义的集合。接口刻画了一个对象可响应的请求的集合。
+ 混入类（mixin class）    一种被设计为通过继承与其他类结合的类。混入类通常是抽象类。
+ 对象（object）    一个封装了数据及作用于这些数据的操作的运行实体。
+ 对象组合（object composition）    组装和组合一组对象以获得更复杂的行为。
+ 对象图（object diagram）    描述运行时刻特定对象结构的示意图。
+ 对象引用（object reference）    用于标识另一个对象的一个值。
+ 操作（operation）    对象的数据仅能由其自身的操作来存取。对象受到请求时执行操作。 *成员函数*
+ 重定义（overriding）    在一个子类中重定义父类继承下来的操作。
+ 参数化类型（parameterized type）    一种含有未确定成分类型的类型。在使用时将未确定类型处理成参数。*模板*
+ 父类（parent class）    被其他类继承的类。*基类* 、 *祖先类*
+ 多态（polymorphism）    在运行时刻接口匹配的对象能互相替换的能力。
+ 私有继承（private inheritance）    一种仅出于实现目的的继承。
+ 协议（protocol）    接口概念的扩展，包含指明可允许的序列。
+ 接收者（receiver）    一个请求的目标对象。
+ 请求（request）    一个对象当受到其他对象的请求时执行相应的操作。通常请求又被称为消息。
+ 型构（signature）    一个操作的型构定义了它的名称、参数和返回值。
+ 子类（subclass）    继承了另一个类的类。 *派生类*
+ 子系统（subsystem）    一组相互协作的类形成的一个相对独立的部分，完成一定的功能。
+ 子类型（subtype）    如果一个类型的接口包含另一个类型的接口，则前一类型称为后一类型的子类型。
+ 超类型（supertype） 为其他类型继承的父类型。
+ 工具箱（toolkit）    一组提供实用功能的类，但它们并不包含任何具体应用的设计。
+ 类型（type）    一个特定接口的名称。
+ 白箱复用（white-box reuse）    一种基于类继承的复用。子类复用父类的接口和实现，但它也可能存取其父类的其他私有部分。
















