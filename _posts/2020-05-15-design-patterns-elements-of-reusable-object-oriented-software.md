---
title: 设计模式——可复用面向对象软件的基础
categories:
- 设计模式
description: 计模式——可复用面向对象软件的基础
permalink: "/posts/design-patterns-elements-of-reusable-object-oriented-softwar"
excerpt: 所有结构良好的面向对象软件体系结构中都包含了许多模式。设计模式可以使系统结构更加精巧、简洁和易于理解。
---

[Design Patterns, Elements of Reusable Object-Oriented Software.pdf](https://leezw.net/assets/pdf/Design%20Patterns,%20Elements%20of%20Reusable%20Object-Oriented%20Software.pdf)

# 设计模式

## 创造型模式

+ **abstract factory**：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。(抽象工厂，对象)
+ **builder**：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。(生成器，对象)
+ **factory method**：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。使得一个类的实例化延迟到其子类。(工厂方法，类)
+ **prototype**：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。(原型，对象)
+ **singleton**：保证一个类仅有一个实例，并提供一个访问它的全局访问点。(单例，对象)

## 结构型模式

+ **adapter**：将一个类的接口转换成客户希望的另一个接口。使得原本由于接口不兼容而不能一起工作的类可以一起工作。(适配器,类)
+ **bridge**：将抽象部分与它的实现部分分离，使它们可以独立的变化。(桥接，对象)
+ **composite**：将对象组合成树形结构以表示“部分-整体”的层次结构。使得客户对单个对象和复合对象的使用具有一致性。(组成，对象)
+ **decorator**：动态地给一个对象添加一些额外的职责。就扩展功能而言，比生成子类的方式更灵活。(装饰，对象)
+ **facade**：为子系统中的一组接口提供一个一致的页面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。(外观，对象)
+ **flyweight**：运用共享技术有效地支持大量细粒度的对象。(享元，对象)
+ **proxy**：为其他对象提供一个代理以控制对这个对象的访问。(代理，对象)

## 行为模式

+ **chain of responsibility**：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。(职责链，对象)
+ **command**：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。(命令，对象)
+ **interpreter**：给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。(解释器，对象)
+ **iterator**：提供一种方法顺序访问一个集合对象中各个元素，而又不暴露该对象的内部表示。(迭代器，类)
+ **mediator**：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。(中介者，对象)
+ **memento**：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象外保存这个状态。这样以后就可将该对象恢复到保存的状态。(备忘录，对象)
+ **observer**：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。(观察者，对象)
+ **state**：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎改变了他所属的类。(状态，对象)
+ **strategy**：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。此模式使得算法的变化可独立于它的客户。(策略，对象)
+ **template method**：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。(模板方法，类)
+ **visitor**：表示一个作用于某对象结构中的各元素的操作。他是你可以在不改变个元素的类的前提下定义作用于这些元素的新操作。(访问者，对象)

设计模式展示了如何使用面向对象的继承和实现、方法的重载和重写等基本技术，是对被用来在特定场景下解决一般设计问题的类和相互通信的对象的描述。设计模式包含四个基本要素：模式名称、问题、解决方案、效果。各个模式之间经常会捆绑使用(composite、iterator、visitor)或互相替代(prototype、abstract factory)或尽管意图不同，但产生的设计结果相似(composite、decorator)。它为我们使用的各种技术提供了标准的名称和定义。算法和数据结构会有其命名和分类，但我们很少为其他类型的模式命名。设计模式就为设计者们交流讨论，书写文档以及探索更多不同的设计提供了一套通用的设计词汇。同时提供了一些常见问题的解决方案。

开发可复用软件时不得不重新组织或重构软件系统。设计模式可以帮助减少重构工作。面向对象的软件生命周期可分为三个阶段：原型阶段、扩展阶段和巩固阶段。首先建立一个快速原型，在此基础上进行增量式修改直到满足基本需求，然后进入扩展阶段新的需求要求加入新的类和操作甚至整个类层次，软件的不断扩展使其变得膨胀臃肿难以进行进一步修改。该软件若要继续演化就必须进行重新组织，这个过程称为 *重构* 。框架常常在这个阶段出现。重构工作包括将类拆分为专用和通用构件，并使各个类的接口合理化。

好的设计者不仅知道哪些变化会促使重构，还要知道哪些类和对象结构能够避免重构，使得设计对需求的变化具有健壮性。对需求的彻底分析有助于突出易于发生变化的需求。设计模式可以尽量防止以后的重构。


# 创造型模式

创建型模式抽象了实例化过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。一个类创建型模式使用继承改变被实例化的类，而一个对象创建型模式将实例化委托给另一个对象。

随着系统演化得越来越依赖于对象复合而不是类继承，创建型模式变得更为重要。当这种情况发生时，重心从对一组固定行为的硬编码转移为定义一个较小的基本行为集，这些行为可以被组合成任意数目的更复杂的行为。这样创建有特定行为的对象要求的不仅仅是实例化一个类。

在这些模式中有两个不断出现的主旋律。第一，它们都将关于该系统使用哪些具体的类的信息封装起来。第二，它们隐藏了这些类的实例是如何被创建和放在一起的。整个系统关于这些对象所知道的是由抽象类所定义的接口。因此，创建型模式在什么被创建，谁创建它,
它是怎样被创建的，以及何时创建这些方面给予你很大的灵活性。它们允许你用结构和功能差别很大的“产品”对象配置一个系统。配置可以是静态的(即在编译时指定),也可以是动态的(在运行时)。

有时创建型模式是相互竞争的。例如，在有些情况下Prototype或Abstract Factory用起来都很好。而在另外一些情况下它们是互补的: Builder 可以使用其他模式去实现某个构件的创建。Prototype 可以在它的实现中使用Singleton。

用一个系统创建的那些对象的类对系统进行参数化有两种常用方法。一种是生成创建对象的类的子类;这对应于使用Factory Method 模式。这种方法的主要缺点是，仅为了改变产品类，就可能需要创建一个新的子类。这样的改变可能是级联的。例如，如果产品的创建者本身是由一个工厂方法创建的，那么你也必须重定义它的创建者。

另一种对系统进行参数化的方法更多的依赖于对象复合:定义一个对象负责明确产品对象的类，并将它作为该系统的参数。这是Abstract Factory、 Builder和Prototype模式的关键特征。所有这三个模式都涉及到创建一个新的负责创建产品对象的“工厂
对象”。Abstract Factory由这个工厂对象产生多个类的对象。Builder由这个工厂对象使用一个相对复杂的协议，逐步创建一个复杂产品。Prototype由该工厂对象通过拷贝原型对象来创建产品对象。在这种情况下，因为原型负责返回产品对象，所以工厂对象和原型是同一个对象。

考虑在Prototype模式中描述的绘图编辑器框架。可以有多种方法通过产品类来参数化GraphicTool:

+ 使用Factory Method模式，将为选择板中的每个Graphic的子类创建一个GraphicTool的子类。GraphicTool将有一个NewGraphic操作， 每个GraphicTool的子类都会重定义它。
+ 使用Abstract Factory模式，将有一个GraphicsFactory类层次对应于每个Graphic的子类。在这种情况每个工厂仅创建一个产品: CircleFactory将创建Circle, LineFactory将创建Line,等等。GraphicTool将以创建合适种类Graphic的工厂作为参数。
+ 使Prototype模式，每个Graphic的子类将实现Clone操作,并且GraphicTool将以它所创建的Graphic的原型作为参数。

究竟哪一种模式最好取决于诸多因素。在我们的绘图编辑器框架中，第一眼看来, Factory Method模式使用是最简单的。它易于定义一个新的GraphicTool的子类，并且仅当选择板被定义了的时候，GraphicTool的实例才被创建。它的主要缺点在于GraphicTool子类数目的激增,并且它们都没有做很多事情。

Abstract Factory并没有很大的改进，因为它需要一个同样庞大的GraphicsFactory类层次。只有当早已存在一个GraphicsFactory类层次时，Abstract Factory才比Factory Method更好一点——或是因为编译器自动提供或是因为系统的其他部分需要这个GraphicsFactory类层次。

总的来说，Prototype模式对绘图编辑器框架可能是最好的，因为它仅需要为每个Graphics类实现一个Clone操作。这就减少了类的数目，并且Clone可以用于其他目的而不仅仅是纯粹的实例化。

Factory Method使一个设计可以定制且只略微有一些复杂。其他设计模式需要新的类，而Factory Method只需要一个新的操作。人们通常将Factory Method作为一种标准的创建对象的方法。但是当被实例化的类根本不发生变化或当实例化出现在子类可以很容易重定义的操作中(比如在初始化操作中)时，这就并不必要了。

使用Abstract Factory、 Prototype 或Builder的设计甚至比使用Factory Method的那些设计更灵活，但它们也更加复杂。通常，设计以使用Factory Method开始，并且当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。当你在设计标准之间进行权衡的时候，了解多个模式可以给你提供更多的选择余地。

## 简单工厂模式

简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式。

# 结构型模式

结构型模式涉及到如何组合类和对象以获得更大的结构。结构型类模式采用继承机制来组合接口或实现。一个简单的例子是采用多重继承方法将两个以上的类组合成一个类，结果这个类包含了所有父类的性质。这一模式尤其有助于多个独立开发的类库协同工作。另外一个例子是类形式的Adapter模式。一般来说，适配器使得一个接口（adaptee的接口）与其他接口兼容，从而给出了多个不同接口的统一抽象。为此，类适配器对一个adaptee类进行私有继承。这样适配器就可以用adaptee的接口标识它的接口。

结构型对象模式不是对结构和实现进行组合，而是描述了如何对一些对象进行组合，从而实现新功能的一些方法。因为可以在运行时刻改变对象组合关系，所以对象组合方式具有更大的灵活性，而这种机制用静态类组合是不可能实现的。

Composite模式是结构型对象模式的一个实例。它描述了如何构造一个类层次结构，这一结构由两种类型对象（基元对象和组合对象）所对应的类构成，其中的组合对象使得你可以组合基元对象以及其他的组合对象，从而形成任意复杂的结构。在Proxy模式中，proxy对象作为其他对象的一个方便的替代或占位符。它的使用可以有多种形式。例如它可以在局部空间中代表一个远程地址空间中的对象，也可以表示一个要求被加载的较大的对象，还可以用来保护对敏感对象的访问。Proxy模式还提供了对对象的一些特有性质的一定程度上的间接访问，从而它可以限制、增强或修改这些性质。

Flyweight模式为共享对象定义了一个结构。至少有两个原因要求对象共享：效率和一致性。Flyweight的对象共享机制主要强调对象的空间效率。使用很多对象的应用必须考虑每一个对象的开销。使用对象共享而不是进行对象复制，可以节省大量的空间资源。但是仅当这些对象没有定义与上下文相关的状态时，它们才可以被共享。Flyweight的对象没有各样的状态。任何执行任务时需要的其他一些信息仅当需要时才传递过去。由于不存在与上下文相关的状态，因此Flyweight对象可以被自由的共享。

如果说Flyweight模式说明了如何生成很多较小的对象，那么Facade模式则描述了如何用单个对象表示整个子系统。模式中的facade用来表示一组对象，facade的职责是将消息转发给它所表示的对象。Bridge模式将对象的抽象和其实现分离，从而可以独立地改变它们。

Decoragtor模式描述了如何动态地为对象添加职责。Decorator模式是一种结构型模式。这一模式采用递归方式组合对象，从而允许你添加任意多的对象职责。例如，一个包含用户界面组件的Decorator对象可以将边框或阴影这样的装饰添加到该组件中，或者它可以将窗口和缩放这样的功能添加到组件中。我们可以将一个Decorator对象嵌套在另外一个对象中就可以很简单的增加两个装饰，添加其他的装饰也是如此。因此，每个Decorator对象必须与其他组件的接口兼容并且保证将消息传递给它。Decorator模式在转发一条消息之前或之后都可以完成它的工作。

Adapter模式和Bridge模式具有一些共同的特性。它们都给另一对象提供了一定程度上的间接性，因而有利于系统的灵活性。它们都涉及到从自身以外的一个接口向这个对象转发请求。

这些模式的不同之处主要在于它们各自的用途。Adapter模式主要是为了解决两个已有接口之间不匹配的问题。它不考虑这些接口是怎样实现的，也不考虑它们各自可能会如何演化。这种方式不需要对两个独立设计的类中的任一个进行重新设计，就能够使它们协同工作。另一方面，Bridge模式则与对抽象接口与它的实现部分进行桥接。虽然这一模式允许你修改实现了它的类，它仍然为用户提供了一个稳定的接口。Bridge模式也会在系统演化时适应新的实现。

由于这些不同点，Adapter和Bridge模式通常被用于软件生命周期的不同阶段。当你发现两个不兼容的类必须同时工作时，就有必要使用Adapter模式，其目的一般是为了避免代码重复。此处耦合不可预见。相反，Bridge的使用者必须事先知道：一个抽象将有多个实现部分，并且抽象和实现两者是独立演化的。Adapter模式在类已经设计好后实施；而Bridge模式在设计类之前实施。这并不意味着Adapter模式不如Bridge模式，只是因为它们针对了不同的问题。

你可能认为facade是另外一组对象的适配器。单这种解释忽视了一个事实：Facade定义一个新的接口，而Adapter则复用一个原有的接口。适配器使两个已有的接口协同工作，而不是定义一个全新的接口。

Composite模式和Decoratro模式具有类似的结构图，这说明它们都基于递归组合来组织可变数目的对象。Decorator旨在使你能够不需要生成子类即可给对象添加职责。这就避免了静态实现所有功能组合，从而导致子类急剧增加。Composite则有不同的目的，它旨在构造类，使多个相关的对象能够以统一的方式处理，而多重对象可以被当作一个对象来处理。它重点不在于修饰，而在于表示。

尽管它们的目的截然不同，但却具有互补性。因此Composite和Decorator模式通常协同使用。在使用这两种模式进行设计时，我们无需定义新的类，仅需将一些对象插接在一起即可构建应用。这时系统中将有一个抽象类，它有一些composite子类和decorator子类，还有一些实现系统的基本构建模块。此时composite和decorator将拥有共同的接口。从Decorator模式的角度看，composite是一个ConcreteComponent。而从composite模式的角度看，decorator则是一个Leaf。

另一种与Decorator模式结构相似的模式是Proxy。这两种模式都描述了怎样为对象提供一定程度上的间接引用，proxy和decorator对象的实现部分都保留了指向另一个对象的指针，它们向这个对象发送请求。

像Decorator模式一样，Proxy模式构成一个对象并为用户提供一致的接口。但与Decorator模式不同的是，Proxy模式不能动态地添加或分离性质，它也不是为递归组合而设计的。它的目的是，当直接访问一个实体不方便或不符合需要时，为这个实体提供一个替代者，例如实体在远程设备上，访问受到限制或者实体是持久存储的。

在Proxy模式中，实体定义了关键功能，而Proxy提供对它的访问。在Decorator模式中，组件仅提供了部分功能，而一个或多个Decorator负责完成其他功能。Decorator模式适用于编译时不能确定对象的全部功能的情况。这种开发性使递归组合成为Decorator模式中一个必不可少的部分。而在Proxy模式中则不是这样，因为Proxy模式强调一种代理与实体的关系，这种关系可以静态的表达。

模式间的这些差异非常重要，因为它们针对了面向对象设计过程中一些特定的经常发生问题的解决方法。但这并不意味着这些模式不能结合使用。

# 行为模式

行为模式涉及到算法和对象职责的分配。行为模式不仅描述对象或类的模式，还描述它们之间的通信模式。这些模式刻划了在运行时难以跟踪的复杂的控制流。它们将你的注意力从控制流转移到对象间的联系方式上来。

行为模式使用继承机制在类间分派行为。其中Template Method较为简单和常用。模板方法是一个算法的抽象定义，它逐步的定义该算法，每一步调用一个抽象操作或一个原语操作，自类定义抽象操作以具体实现该算法。另一种行为模式是Interpreter。它将一个文法表示为一个类层次，并实现一个解释器作为这些类实例上的一个操作。

行为对象模式使用对象复合而不是继承。一些行为对象模式描述了一组对象的对象怎样互相协作以完成其中任一个对象都无法单独完成的任务。这里一个重要的问题是对等的对象如何互相了解对方。对等对象可以保持显式的对对方的引用，但那会增加他们的耦合度。在极端情况下，每一个对象都要了解所有其他的对象。Mediator在对等对象间引入一个mediator对象以避免这种情况的出现。mediator提供了松耦合所需的间接性。

Chain of Responsibility提供更松的耦合。它让你通过一条候选对象链隐式的向一个对象发送请求。根据运行时刻情况任一候选者都可以响应相应的请求。候选者的数目是任意的，你可以在运行时刻决定哪些候选者参与到链中。

Observer模式定义并保持对象间的依赖关系。其他的行为对象模式常将行为封装在一个对象中并将请求指派给它。Strategy模式将算法封装在对象中，这样可以方便地指定和改变一个对象所使用的的算法。Command模式将请求封装在对象中，这样它就可作为参数来传递，也可以被存储在历史列表里，或者以其他方式使用。State模式封装一个对象的状态，使得当这个对象的状态对象变化时，该对象可改变它的行为。Visitor封装分布于多个类之间的行为，而Iterator则抽象了访问和遍历一个集合中的对象的方式。

各个行为模式之间是相互补充和相互加强的关系。例如，一个职责链中的类可能包含至少一个Template Method的应用。该模板方法可使用原语操作确定该对象是否应处理该请求并选择应转发的对象。职责链可以使用Commond模式将请求表示为对象。Iterpreter可以使用State模式定义语法分析上下文。迭代器可以遍历一个聚合，而访问者可以对它的每一个元素进行一个操作。

行为模式也能与其他模式很好的协同工作。例如，一个使用Composite模式的系统可以使用一个访问者对该复合的各成分进行一些操作。它可以使用职责链使得各成分可以通过它们的父类访问某些全局属性。它也可以使用Decorater对该复合的某些部分的这些属性进行改写。它可以使用Observer模式将一个对象结构与另一个对象结构联系起来，可以使用State模式使得一个构件在状态改变时可以改变自身的行为。复合本身可以使用Builder中的方法创建，并且它可以被系统中的其他部分当作一个Prototype。

设计良好的面向对象式系统通常有多个模式镶嵌在其中，单其设计者却未必使用这些术语进行思考。然而，在模式级别而不是在类或对象级别上的进行系统组装可以使我们更方便地获取同等的协同性。

## Chain of Responsibility(职责链)——对象行为型模式

### 意图

使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链,并沿着这条链传递该请求，直到有一个对象处理它为止。

### 适用性

+ 有多个对象可以处理一个请求，哪个对象处理该请求运行时自动确定
+ 在不明确指定接收者的情况下，向多个对象中的一个提交请求
+ 可处理请求的对象集合应被动态指定

### 结构

![职责链UML](/assets/images/design-patterns-elements-of-reusable-object-oriented-software/职责链UML.png)

![职责链对象结构](/assets/images/design-patterns-elements-of-reusable-object-oriented-software/职责链对象结构.png)

### 参与者

+ Handler
  + 定义一个车处理请求的接口
  + 实现后继链
+ ConcreteHandler
  + 处理它负责的请求
  + 可访问它的后继者
  + 如果可以处理请求就处理，否则向后传递请求
+ Client
  + 向职责链提交请求
  
### 效果

+ 降低耦合度，接收者和发送者互相不耦合
+ 增加了给对象指派职责的灵活性，可以再运行时动态对职责链进行修改
+ 不保证被接受，可能链内没有可以处理请求的对象，或者链没有正确的配置

### 实现

+ 实现后继者链
  + 定义新的链
  + 使用已有的链接
+ 链接后继者
  + 如果没有已有的引用可以定义一个链，那么必须自己引入处理对象链，那么Handler不仅定义该请求的接口，通常也维护后继链接，这样Handler就提供了向后继者转发请求的缺省实现
+ 表示请求
  + 硬编码
  + 使用专门的处理函数来处理双方约定的请求码
  + 封装请求对象

### 相关模式

职责链通常与Composite一起使用，这样一个构件的父构件可作为它的后继处理对象。

## COMMAND（命令）——对象行为型模式

### 意图

讲一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

### 别名

动作(Action)、事务(Transaction)

### 动机

命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。

### 适用性

+ 抽象并把待执行的动作参数化，和回调机制类似
+ 在不同的时刻指定请求，排列请求和执行请求
+ 支持请求的撤销和恢复，在Command接口中添加一个Unexecute操作用来取消上一次的Execute操作
+ 记录命令日志，在Command接口中添加加载操作和存储操作，这样可以故障恢复
+ 将一组操作组合成一个命令，即原子和宏命令

### 结构

![命令模式对象结构](/assets/images/design-patterns-elements-of-reusable-object-oriented-software/命令模式对象结构.png)

### 参与者

+ Command
  + 声明执行操作的接口。
+ ConcreteCommand (PasteCommand, OpenCommand)
  + 将一个接收者对象绑定于一个动作。
  + 调用接收者相应的操作，以实现Execute。
+ Client (Appliction)
  +创建一个具体命令对象并设定它的接收者。
+ Invoker (MenuItem)
  + 要求该命令执行这个请求。
+ Receiver (Document, Application)
  + 知道如何实施与执行一个请求相关的操作。任何类都可能作为一个接收者。

### 协作

1. Client创建一个ConcreteCommand对象并指定它的Receiver对象。
2. 某Invoker对象存储该ConcreteCommand对象。
3. 该Invoker通过调用Command对象的Execute操作来提交一个请求。若该命令是可撤消的，ConcreteCommand就在执行Excute操作之前存储当前状态以用于取消该命令。
4. ConcreteCommand对象对调用它的Receiver的一些操作以执行该请求。

![命令模式协作图](/assets/images/design-patterns-elements-of-reusable-object-oriented-software/命令模式协作图.png)

### 效果

+ Command模式将调用操作的对象与知道如何实现该操作的对象解耦。
+ Command是头等的对象。它们可像其他的对象一样被操纵和扩展。
+ 你可将多个命令装配成一个复合命令。例如是前面描述的MacroCommand类。一般说来复合命令是Composite模式的一个实例。
+ 增加新的Command很容易，因为这无需改变已有的类。

### 实现

+ 一个命令对象的能力大小，它可以仅是一个命令，也可以实现所有的动作
+ 是否需要支持undo和redo，如果需要支持可能需要额外的状态信息：
  + 接收者对象，它真正执行处理该请求的各操作。
  + 接收者上执行操作的参数。
  + 如果处理请求的操作会改变接收者对象中的某些值,那么这些值也必须先存储起来。接收者还必须提供一些操作，以使该命令可将接收者恢复到它先前的状态。
  + 如果只支持一次取消，那次只存储最近一次被执行的命令。要支持多级取消和重做，要有一个历史命令列表
+ 避免取消操作过程中的错误积累，由于命令重复执行、取消执行可能会累计错误，以至一个应用的状态最终偏离初始值。这就必要在Command中存储更多的信息。可以使用Memento模式来让该Command访问这些信息而不暴露其他对象的内部信息。
+ 对于不能被取消和不需要参数的命令，可以使用c++模板或java泛型

### 相关模式

Composite模式可被用来实现宏命令。
Memento模式可用来保持某个状态，命令用这一状态来取消它的效果。在被放入历史表列前必须被拷贝的命令起到一种原型的作用。

## INTERPRETER(解释器)——类行为模式

### 意图

文法解析

### 动机

如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器,该解释器通过解释这些句子来解决该问题。例如正则表达式，SpEL。

### 结构

![解释器结构](/assets/images/design-patterns-elements-of-reusable-object-oriented-software/解释器结构.png)

### 参与者

+ AbstractExpression
  + 声明一个抽象的解释操作，这个接口为抽象语法树中所有的节点共享
+ TerminalExpression
  + 实现与文法中的终结符相关联的解释操作
  + 一个句子中的每个终结符需要该类的一个实例
+ NonterminalExpression
  + 对文法中的每一条规则R ::= R1R2...Rn都需要一个这个类
  + 为从R1到Rn的每个符号都维护一个AbstractExpression类型的实例变量
  + 为文法中的非终结符实现解释操作。解释一般要递归地调用表示R1到Rn的那些对象的解释操作
+ Context
  + 包含解释器之外的一些全局信息
+ Client
  + 构建表示该文法定义的语言中一个特定的句子的抽象语法树。该抽象语法树由NonterminalExpression和TerminalExpression的实例装配而成
  + 调用解释操作

### 协作

+ Client构建一个句子，它是NonterminalExpression和TerminalExpression的实例的一个抽象语法树。然后初始化上下文并调用解释操作
+ 每一非终结符表达式节点定义相应子表达式的解释操作。而各终结符表达式的解释操作构成了递归的基础
+ 每一节点的解释操作用上下文来存储和访问解释器的状态

### 效果

+ 易于改变和扩展文法，因为该模式使用类来表示文法规则，你可使用继承来改变或扩展该文法。已有的表达式可被增量式地改变,而新的表达式可定义为旧表达式的变体。
+ 也易于实现文法，定义抽象语法树中各个节点的类的实现大体类似。这些类易于直接编写，通常它们也可用一个编译器或语法分析程序生成器自动生成。
+ 复杂的文法难以维护，解释器模式为文法中的每一 条规则至少定义了一个类(使用BNF定义的文法规则需要更多的类)。因此包含许多规则的文法可能难以管理和维护。可应用其他的设计模式来缓解这一问题。但当文法非常复杂时,其他的技术如语法分析程序或编译器生成器更为合适。
+ 增加了新的解释表达式的方式，解释器模式使得实现新表达式“计算”变得容易。例如，你可以在表达式类上定义一个新的操作以支持优美打印或表达式的类型检查。如果你经常创建新的解释表达式的方式，那么可以考虑使用Visitor模式以避免修改这些代表文法的类。

###  实现

+ 创建抽象语法树，解释器模式并未解释如何创建一个抽象的语法树。换言之，它不涉及语法分析。抽象语法树可用一个表驱动的语法分析程序来生成，也可用手写的(通常为递归下降法)语法分析程序创建，或直接由Client提供
+ 定义解释操作，并不一定要在表达式类中定义解释操作。如果经常要创建一种新的解释器，那么使用Visitor模式将解释放人一个独立的“访问者” 对象更好一些。例如，一个程序设计语言的会有许多在抽象语法树上的操作，比如类型检查、优化、代码生成。恰当的做法是使用一个访问者以避免在每一-个类上都定义这些操作
+ 与Flyweight模式共享终结符，在一些文法中,一个句子可能多次出现同一个终结符。此时最好共享那个符号的单个拷贝。计算机程序的文法是很好的例子一每个程序变量在整个代码中将会出现多次。

### 相关模式

Composite模式:抽象语法树是一个复合模式的实例
Flyweight模式: 说明了如何在抽象语法树中共享终结符
Iterator:解释器可用一个迭代器遍历该结构
Visitor:可用来在一个类中维护抽象语法树中的各节点的行为

## ITERATOR(迭代器)——对象行为型模式

### 意图

提供一种不需要暴露对象内部成员变量的方法来顺序访问一个聚合对象中各个元素

### 别名

游标 Cursor

### 动机

将对聚合类的访问和遍历从聚合类对象中分离出来放入一个迭代器对象中。迭代器类定义了一个访问该列表元素的接口。迭代器对象负责跟踪当前元素。不同的迭代器实现可以实现不同的遍历策略而无需体现在聚合类接口中。

迭代器和聚合类是耦合在一起的。聚合对象负责创建相应的迭代器，并负责关联聚合类和迭代器。

### 适用性

+ 访问一个聚合对象的内容而无需暴露它的内部表示
+ 支持对聚合对象的多种遍历
+ 为遍历不同的聚合结构提供一个统一的接口，即支持多态迭代

### 结构

![迭代器结构](/assets/images/design-patterns-elements-of-reusable-object-oriented-software/迭代器结构.png)

### 参与者

+ Iterator
  + 迭代器定义访问和遍历元素的接口
+ ConcreteIterator
  + 具体迭代器实现迭代器接口
  + 对该聚合遍历时跟踪当前位置
+ Aggregate
  + 聚合定义创建响应迭代器对象的接口
+ ConcreteAggregate
  + 具体聚合实现创建相应迭代器的接口，该操作返回ConcreteIterator的一个适当的实例

### 协作

ConcreteIterator跟踪聚合中的当前对象，并能够计算出待遍历的后继对象

### 效果

+ 它支持以不同的方式遍历一个聚合，复杂的聚合可用多种方式进行遍历
+ 迭代器简化了聚合的接口，有了迭代器的遍历接口，聚合本身就不再需要类似的遍历接口
+ 在同一个聚合上可以有多个遍历，每个迭代器保持它自己的遍历状态，因此可以同时进行多个遍历

### 实现

+ 谁控制该迭代，当由客户来控制迭代时,该迭代器称为一个外部迭代器, 而当由迭代器控制迭代时,该迭代器称为一个内部迭代器。使用外部迭代器的客户必须主动推进遍历的步伐，显式地向迭代器请求下一个元素。相反地,若使用内部迭代器，客户只需向其提交一个待执行的操作，而迭代器将对聚合中的每一个元素实施该操作。

+ 谁定义遍历算法，迭代器不是唯一可定义遍历算法的地方。聚合本身也可以定义遍历算法，并在遍历过程中用迭代器来存储当前迭代的状态。我们称这种迭代器为一个游标,因为它仅用来指示当前位置。客户会以这个游标为一个参数调用该聚合的Next操作,而Next操作将改变这个指示器的状态。如果迭代器负责遍历算法，那么将易于在相同的聚合上使用不同的迭代算法，同时也易于在不同的聚合上重用相同的算法。从另一方面说,遍历算法可能需要访问聚合的私有变量。如果这样，将遍历算法放入迭代器中会破坏聚合的封装性。

+ 迭代器健壮程度如何，在遍历一个聚合的同时更改这个聚合可能是危险的。如果在遍历聚合的时候增加或删除该聚合元素,可能会导致两次访问同一个元素或者遗漏掉某个元素。一个简单的解决办法是拷贝该聚合，并对该拷贝实施遍历,但一般来说这样做代价太高。一个健壮的迭代器保证插人和删除操作不会干扰遍历,且不需拷贝该聚合。有许多方法来实现健壮的迭代器。其中大多数需要向这个聚合注册该迭代器。当插人或删除元素时，该聚合要么调整迭代器的内部状态,要么在内部的维护额外的信息以保证正确的遍历。

+ 附加的迭代器操作，迭代器的最小接口由First、Next、IsDone和CurrentItem操作组成。其他一些操作可能也很有用。例如,对有序的聚合可用一个Previous操作将迭代器定位到前一个元素。SkipTo操作用于已排序并做了索引的聚合中，它将迭代器定位到符合指定条件的元素对象上。

+ 迭代器可有特权访问，迭代器可被看为创建它的聚合的一个扩展。迭代器和聚合紧密耦合。在C++中我们可让迭代器作为它的聚合的一个友元来表示这种紧密的关系。这样你就不需要在聚合类中定义一些仅为迭代器所使用的操作。但是,这样的特权访问可能使定义新的遍历变得很难,因为它将要求改变该聚合的接口增加另一个友元。为避免这一问题，迭代器类可包含一些protected操作来访问聚合类的重要的非公共可见的成员。迭代器子类可使用这些protected操作来得到对该聚合的特权访问。

+ 用于复合对象的迭代器，在Composite模式中的那些递归聚合结构上,外部迭代器可能难以实现，因为在该结构中不同对象处于嵌套聚合的多个不同层次，因此一个外部迭代
器为跟踪当前的对象必须存储一条纵贯该Composite的路径。有时使用一个内部迭代器会更容易一些。它仅需递归地调用自己即可，这样就隐式地将路径存储在调用栈中，而无需显式地维护当前对象位置。

+ 空迭代器，一个空迭代器是一个退化的迭代器,它有助于处理边界条件，例如属性结构聚合的叶子节点。根据定义，一个NullIterator总是已经完成了遍历:即它的IsDone操作总是返回true。

### 相关模式

Composite:迭代器常被应用到象复合这样的递归结构上
Factory Method:多态迭代器靠Factory Method来例化适当的迭代器子类
Memento:常与迭代器模式一起使用。迭代器可使用一个memento来捕获一个迭代的状态。迭代器在其内部存储memento

## MEDIATOR(中介者)——对象行为型模式

### 意图

用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

### 动机

虽然将一个系统分割成许多对象通常可以增强可复用性，但是对象间相互连接又会降低其可复用性。

### 适用性

+ 一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解
+ 一个对象引用其他很多对象并且直接与这些对象通信,导致难以复用该对象
+ 想定制一个分布在多个类中的行为，而又不想生成太多的子类

### 结构

![中介者模式结构](/assets/images/design-patterns-elements-of-reusable-object-oriented-software/中介者模式结构.png)

### 参与者

+ Mediator
  + 中介者定义一个接口用于与各Colleague对象通信
+ ConcreteMediator
  + 具体中介者通过协调各Colleague实现协作行为
  + 了解并维护它的各Colleague
+ Colleague class
  + 每个Colleague都知道它的中介者对象
  + 每个Colleague在需与其他的Colleague通信的时候，与它的中介者通信。
  
### 协作

Colleague向一个中介者对象发送和接收请求。中介者在各Colleague间适当地转发请求以实现协作。

### 效果

+ 减少了子类生成，Mediator将原本分布于多个对象间的行为集中在一起。改变这些行为只需生成Meditator的子类即可。这样各个Colleague类可被重用。
+ 它将各Collague解耦，Mediator有利于各Colleague间的松耦合，你可以独立的改变和复用各Colleague类和Mediator类。
+ 它简化了对象协议，用Mediator和各Colleague间的一对多的交互来代替多对多的交互。一对多的关系更易于理解、维护和扩展。
+ 它对对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，使你将注意力从对象各自本身的行为转移到它们之间的交互上来。这有助于弄清楚一个系统中的对象是如何交互的。
+ 它使控制集中化，中介者模式将交互的复杂性变为中介者的复杂性。因为中介者封装了协议,它可能变得比任一个Colleague都复杂。这可能使得中介者自身成为一个难于维护的庞然大物。

### 实现

+ 忽略抽象的Mediator类，当各Colleague仅与一个Mediator一起工作时， 没有必要定义一个抽象的Mediator类。Mediator类提供的抽象耦合已经使各Colleague可与不同的Mediator子类一起工作,反之亦然。
+ Colleague与Mediator通信，当一个感兴趣的事件发生时, Colleague必须与其Mediator通信。一种实现方法是使用Observer模式，将Mediator实现为一个Observer,各Colleague作为Subject，一旦其状态改变就发送通知给Mediator。Mediator作出的响应是将状态改变的结果传播给其他的Colleague。另一个方法是在Mediator中定义一个特殊的通知接口,各Colleague在通信时直接调用该接口。

### 相关模式

Facade与中介者的不同之处在于它是对一个对象子系统进行抽象，从而提供了一个更为方便的接口。它的协议是单向的，即Facade对象对这个子 系统类提出请求，但反之则不
行。相反，Mediator提供了各Colleague对象不支持或不能支持的协作行为，而且协议是多向的。

Colleague可使用Observer模式与Mediator通信。

## MEMENTO(备忘录)——对象行为型模式

### 意图

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

### 别名

Token

### 动机

记录一个对像的内部状态。

### 适用性

+ 保存一个对象的状态用于恢复

### 结构

![备忘录模式结构](/assets/images/design-patterns-elements-of-reusable-object-oriented-software/备忘录模式结构.png)

### 参与者

+ Memento(备忘录)
  + 备忘录存储原发器对象的内部状态。原发器根据需要决定备忘录存储原发器的哪些内部状态。
  + 防止原发器以外的其他对象访问备忘录。备忘录实际上有两个接口，管理者(caretaker)只能看到备忘录的窄接口一它只能将备忘录传递给其他对象。相反,原发器能够看到一个宽接口,允许它访问返回到先前状态所需的所有数据。理想的情况是只允许生成本备忘录的那个原发器访问本备忘录的内部状态。
+ Originator(原发器)
  + 原发器创建一个备忘录,用以记录当前时刻它的内部状态。
  + 使用备忘录恢复内部状态。
+ Caretaker(负责人)
  + 负责保存好备忘录。
  + 不能对备忘录的内容进行操作或检查。

### 协作

+ 管理器向原发器请求一个备忘录,保留一段时间后,将其送回给原发器。
+ 备忘录是被动的。只有创建备忘录的原发器会对它的状态进行赋值和检索。

![备忘录模式时序图](/assets/images/design-patterns-elements-of-reusable-object-oriented-software/备忘录模式时序图.png)

### 效果

+ 保持封装边界，把Originator内部信息对其他对象屏蔽
+ 简化了原发器，让客户端管理它们请求的状态将会简化Originator，并且客户端工作结束时无需通知原发器
+ 使用备忘录可能代价很高，在拷贝存储大量信息并频繁的创建和恢复的时候
+ 定义窄接口和宽接口
+ 维护备忘录的潜在代价，因为管理器不知道备忘录中有多少个状态。

### 实现

+ 备忘录的两个接口：原发器所使用的宽接口和其他对象使用的窄接口需要语言支持
+ 如果备忘录创建和恢复的顺序是可预测的，可以进存储原发器内部状态的增量改变

### 相关模式

+ 








# 附录——词汇表

+ 抽象类（abstract class）    一种主要用于定义接口的类。抽象类中的部分或全部操作被延迟到子类中实现。抽象类不能实例化。
+ 抽象耦合（abstract coupling）    若类A维护了一个指向类B的引用，称A抽象耦合于B。因为A指向的是对象类型而不是对象实例。
+ 抽象操作（abstract operation）    一种声明了结构而没有实现的操作。比如 *纯虚成员函数* 。
+ 相识关系（acquaintance relationship）    如果一个类指向另一个类，则两个类之间有相识关系。
+ 聚合对象（aggregate object）    一种包含子对象的对象。这些子对象称为聚合对象的部分，而聚合对象对它们负责。
+ 聚合关系（aggregation relationship）    聚合对象与其部分之间的关系。类为其对象定义这种关系。
+ 黑箱复用（black-box reuse）    一种基于对象组合的复用方式。这些被组合的对象之间并不开放各自的内部细节。
+ 类（class）    类定义对象的接口个实现。规定对象的内部表示，定义对象可实施的操作。
+ 类图（class diagram）    类图描述类及其内部结构和操作，以及类间的静态关系。
+ 类操作（class operation）    以类而不是单独的对象为目标的操作。比如 *静态成员函数* 。
+ 具体类（concrete class）    不含抽象操作的类，可以实例化。
+ 构造器（constructor）    系统自动调用用来初始化新对象实例的操作。
+ 耦合（coupling）    软件构件之间相互依赖的程度。
+ 委托（delegation）    一个对象把发送给它的请求转发/委托为另一个对象。而受委托对象代表原对象执行请求操作。
+ 设计模式（design pattern）    针对面向对象系统中重复出现的设计问题，提出一个通用的设计方案，并予以系统化的命令和动机解释。它描述了问题、解决方案、在什么条件下使用该解决方案及其效果。它还给出了实现要点和实例。该解决方案是解决该问题的一组精心安排的通用的类和对象，再经定制和实现就可用来解决特定上下文的问题。
+ 析构器（destructor）    系统自动调用用来清理即将被删除的对象的操作。
+ 动态绑定（dynamic binding）    在运行时刻才将一个请求与一个对象及其一个操作关联起来。
+ 封装（encapsulation）    其结果是将对象的表示和实现隐藏起来。在对象之外，看不到其内部表示，也不能直接对其进行访问。操作是访问和修改对象表示的唯一途径。
+ 框架（framework）    一组相互协作的类，形成某类软件的一个可复用设计。框架将设计划分为一组抽象类，并定义它们各自的职责及相互之间的合作，以此来指到体系结构级的设计。开发者通过继承框架中的类和组合其实例来定制框架以生成特定的应用。
+ 友类（friend class）    A为B的友类，A对B中的操作和数据有与B本身一样的访问权限。
+ 继承（inheritance）    两个实体间的一种关系，其中一实体是基于另一个实体而定义的。子类继承父类的接口和实现，也叫派生类。类继承包含了接口继承和实现继承。接口继承以一个或多个已有接口为基础定义新的接口。
+ 实例变量（instance variable）    定义部分对象表示的数据。也叫 *数据成员* 。
+ 交互图（interaction diagram）    展示对象间请求流程的一种示意图。
+ 接口（inteface）    一个对象所有操作定义的集合。接口刻画了一个对象可响应的请求的集合。
+ 混入类（mixin class）    一种被设计为通过继承与其他类结合的类。混入类通常是抽象类。
+ 对象（object）    一个封装了数据及作用于这些数据的操作的运行实体。
+ 对象组合（object composition）    组装和组合一组对象以获得更复杂的行为。
+ 对象图（object diagram）    描述运行时刻特定对象结构的示意图。
+ 对象引用（object reference）    用于标识另一个对象的一个值。
+ 操作（operation）    对象的数据仅能由其自身的操作来存取。对象受到请求时执行操作。 *成员函数*
+ 重定义（overriding）    在一个子类中重定义父类继承下来的操作。
+ 参数化类型（parameterized type）    一种含有未确定成分类型的类型。在使用时将未确定类型处理成参数。*模板*
+ 父类（parent class）    被其他类继承的类。*基类* 、 *祖先类*
+ 多态（polymorphism）    在运行时刻接口匹配的对象能互相替换的能力。
+ 私有继承（private inheritance）    一种仅出于实现目的的继承。
+ 协议（protocol）    接口概念的扩展，包含指明可允许的序列。
+ 接收者（receiver）    一个请求的目标对象。
+ 请求（request）    一个对象当受到其他对象的请求时执行相应的操作。通常请求又被称为消息。
+ 型构（signature）    一个操作的型构定义了它的名称、参数和返回值。
+ 子类（subclass）    继承了另一个类的类。 *派生类*
+ 子系统（subsystem）    一组相互协作的类形成的一个相对独立的部分，完成一定的功能。
+ 子类型（subtype）    如果一个类型的接口包含另一个类型的接口，则前一类型称为后一类型的子类型。
+ 超类型（supertype） 为其他类型继承的父类型。
+ 工具箱（toolkit）    一组提供实用功能的类，但它们并不包含任何具体应用的设计。
+ 类型（type）    一个特定接口的名称。
+ 白箱复用（white-box reuse）    一种基于类继承的复用。子类复用父类的接口和实现，但它也可能存取其父类的其他私有部分。



