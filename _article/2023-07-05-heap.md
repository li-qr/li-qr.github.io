---
title: 堆结构
categories:
- 数据结构
- algorithm
description: 堆是一种用数组实现的完全二叉树结构。有最大堆和最小堆两种形式。
permalink: "/posts/heap"
excerpt: 堆是一种用数组实现的完全二叉树结构。有最大堆和最小堆两种形式。
---
+ [数据结构：堆（Heap）](https://www.jianshu.com/p/6b526aa481b1)

在最大堆中，父节点的值比每一个子节点的值都要大。在最小堆中，父节点的值比每一个子节点的值都要小。这就是所谓的“堆属性”，并且这个属性对堆中的每一个节点都成立。堆属性非常有用，因为堆常常被当做优先队列使用，因为可以快速地访问到“最重要”的元素。

## 堆和普通树的区别

堆并不能取代二叉搜索树，它们之间有相似之处也有一些不同。我们来看一下两者的主要差别：

节点的顺序。在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。

内存占用。普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配内存。堆仅仅使用一个数据来存储数组，且不使用指针。

平衡。二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到O(log n)。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足堆属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证O(log n) 的性能。

搜索。在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。

## 用数组表示的树结构

堆的属性特性，可以方便的用数组进行表示。只需要记住三个公式即可。在数组中获取父节点、左右子节点的方式是：

```c
parent(i) = floor((i - 1)/2)
left(i)   = 2i + 1
right(i)  = 2i + 2
```

## 堆上有哪些操作

有两个原始操作用于保证插入或删除节点以后堆是一个有效的最大堆或者最小堆：

* `shiftUp()`: 如果一个节点比它的父节点大（最大堆）或者小（最小堆），那么需要将它同父节点交换位置。这样是这个节点在数组的位置上升。
* `shiftDown()`: 如果一个节点比它的子节点小（最大堆）或者大（最小堆），那么需要将它向下移动。这个操作也称作“堆化（heapify）”。

shiftUp 或者 shiftDown 是一个递归的过程，所以它的时间复杂度是  **O(log n)** 。

基于这两个原始操作还有一些其他的操作：

* `insert(value)`: 在堆的尾部添加一个新的元素，然后使用 `shiftUp` 来修复对。
* `remove()`: 移除并返回最大值（最大堆）或者最小值（最小堆）。为了将这个节点删除后的空位填补上，需要将最后一个元素移到根节点的位置，然后使用 `shiftDown` 方法来修复堆。
* `removeAtIndex(index)`: 和 `remove()` 一样，差别在于可以移除堆中任意节点，而不仅仅是根节点。当它与子节点比较位置不时无序时使用 `shiftDown()`，如果与父节点比较发现无序则使用 `shiftUp()`。
* `replace(index, value)`：将一个更小的值（最小堆）或者更大的值（最大堆）赋值给一个节点。由于这个操作破坏了堆属性，所以需要使用 `shiftUp()` 来修复堆属性。

上面所有的操作的时间复杂度都是  **O(log n)** ，因为 shiftUp 和 shiftDown 都很费时。还有少数一些操作需要更多的时间：

* `search(value)`:堆不是为快速搜索而建立的，但是 `replace()` 和 `removeAtIndex()` 操作需要找到节点在数组中的index，所以你需要先找到这个index。时间复杂度： **O(n)** 。
* `buildHeap(array)`:通过反复调用 `insert()` 方法将一个（无序）数组转换成一个堆。如果你足够聪明，你可以在 **O(n)** 时间内完成。
* 堆排序：由于堆就是一个数组，我们可以使用它独特的属性将数组从低到高排序。时间复杂度： **O(n lg n)** 。

堆还有一个 `peek()` 方法，不用删除节点就返回最大值（最大堆）或者最小值（最小堆）。时间复杂度 **O(1)** 。

> **注意：** 到目前为止，堆的常用操作还是使用 `insert()` 插入一个新的元素，和通过 `remove()`移除最大或者最小值。两者的时间复杂度都是 **O(log n)** 。其其他的操作是用于支持更高级的应用，比如说建立一个优先队列。
>
