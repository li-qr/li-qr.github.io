---
title: JDK源码rt.jar中java.io包拆解
categories:
- jdk8
- rt.jar
- java
- io
description: JDK源码rt.jar中java.io包拆解、详解
permalink: "/posts/jdk-rt-jar-java-io"
excerpt: AutoCloseable、Closeable、InputStream/OutputStream、Reader/Writer、DataInput/DataOutput、ObjectInput/ObjectOutput、RandomAccessFile、IOException、IOError、File
---
基于 jdk8 [https://docs.oracle.com/javase/8/docs/api/index.html](https://docs.oracle.com/javase/8/docs/api/index.html)

Java 中的 IO（Input/Output）和 NIO（New Input/Output）是两种不同的处理输入和输出的方式。它们在设计理念、性能和使用场景上都有显著的区别。

### 1. 设计理念

#### IO（传统 IO）

- **面向流（Stream-Oriented）：** 传统 IO 是基于流的，每次处理一个字节或字符，按顺序进行读取和写入操作。
- **阻塞 IO（Blocking IO）：** 在传统 IO 中，读写操作是阻塞的，即当一个线程执行读写操作时，它将被阻塞，直到操作完成。

#### NIO（新 IO）

- **面向缓冲区（Buffer-Oriented）：** NIO 是基于缓冲区的，数据被读入一个缓冲区，然后从缓冲区中进行处理。缓冲区提高了数据处理的灵活性和效率。
- **非阻塞 IO（Non-Blocking IO）：** NIO 支持非阻塞模式，线程可以在等待数据准备好时执行其他操作。非阻塞 IO 允许更高效地利用系统资源。
- **选择器（Selectors）：** NIO 引入了选择器机制，可以通过一个线程监控多个通道（Channel），从而实现高效的多路复用。

### 2. 性能

- **传统 IO：** 由于是阻塞模式，传统 IO 在高并发场景下性能较差，因为每个连接都需要一个独立的线程来处理。
- **NIO：** 由于支持非阻塞 IO 和选择器机制，NIO 在高并发场景下性能更好，可以通过少量线程管理大量连接，减少了线程切换和资源消耗。

### 3. 编程模型

#### IO（传统 IO）

```java
// 读取文件示例
try (BufferedReader reader = new BufferedReader(new FileReader("example.txt"))) {
    String line;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

#### NIO（新 IO）

```java
// 读取文件示例
try (RandomAccessFile file = new RandomAccessFile("example.txt", "r");
     FileChannel fileChannel = file.getChannel()) {
    ByteBuffer buffer = ByteBuffer.allocate(1024);
    while (fileChannel.read(buffer) > 0) {
        buffer.flip();
        while (buffer.hasRemaining()) {
            System.out.print((char) buffer.get());
        }
        buffer.clear();
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

### 4. 使用场景

#### IO（传统 IO）

- 适用于简单的、小规模的 IO 操作。
- 适用于需要顺序处理数据的场景，如文件读写、简单的网络通信等。

#### NIO（新 IO）

- 适用于高性能、高并发的网络应用，如服务器端编程、聊天室、文件传输等。
- 适用于需要处理大量连接和数据的场景，如大型分布式系统、游戏服务器等。

### 5. 总结

- **传统 IO（IO）：** 简单易用，适用于低并发、顺序处理的数据操作。由于阻塞模式，在高并发场景下性能较差。
- **新 IO（NIO）：** 复杂但高效，适用于高并发、高性能的网络应用。非阻塞模式和选择器机制使其在处理大量连接时表现优异。

选择使用哪种 IO 模型，应根据具体的应用场景和性能要求来决定。对于简单的文件操作和低并发网络通信，传统 IO 通常足够；而对于高并发、高性能需求的网络应用，NIO 则是更好的选择。


在 Java 中，传统 IO（也称为阻塞 IO）提供了一系列用于处理输入和输出操作的类和接口。这些类和接口主要集中在 `java.io` 包中。传统 IO 的使用方式可以分为以下几类：

### 1. 字节流（Byte Streams）

字节流用于处理字节数据，适用于所有类型的 I/O，包括文件、网络连接等。字节流类的基类是 `InputStream` 和 `OutputStream`。

#### 读取字节数据

```java
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

public class ByteStreamReadExample {
    public static void main(String[] args) {
        try (InputStream inputStream = new FileInputStream("example.txt")) {
            int data;
            while ((data = inputStream.read()) != -1) {
                System.out.print((char) data);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

#### 写入字节数据

```java
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class ByteStreamWriteExample {
    public static void main(String[] args) {
        try (OutputStream outputStream = new FileOutputStream("example.txt")) {
            String data = "Hello, World!";
            outputStream.write(data.getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 2. 字符流（Character Streams）

字符流用于处理字符数据，适用于文本文件。字符流类的基类是 `Reader` 和 `Writer`。

#### 读取字符数据

```java
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;

public class CharStreamReadExample {
    public static void main(String[] args) {
        try (Reader reader = new FileReader("example.txt")) {
            int data;
            while ((data = reader.read()) != -1) {
                System.out.print((char) data);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

#### 写入字符数据

```java
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;

public class CharStreamWriteExample {
    public static void main(String[] args) {
        try (Writer writer = new FileWriter("example.txt")) {
            String data = "Hello, World!";
            writer.write(data);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 3. 缓冲流（Buffered Streams）

缓冲流用于提高 I/O 操作的效率，通过减少实际读写操作的次数。常用的缓冲流类有 `BufferedInputStream`, `BufferedOutputStream`, `BufferedReader`, 和 `BufferedWriter`。

#### 读取缓冲字符数据

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class BufferedCharStreamReadExample {
    public static void main(String[] args) {
        try (BufferedReader reader = new BufferedReader(new FileReader("example.txt"))) {
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

#### 写入缓冲字符数据

```java
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class BufferedCharStreamWriteExample {
    public static void main(String[] args) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter("example.txt"))) {
            String data = "Hello, World!";
            writer.write(data);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 4. 数据流（Data Streams）

数据流用于读写基本数据类型（如 `int`, `float`, `double`）和 `String`。常用的类有 `DataInputStream` 和 `DataOutputStream`。

#### 读取数据类型

```java
import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.IOException;

public class DataStreamReadExample {
    public static void main(String[] args) {
        try (DataInputStream dataInputStream = new DataInputStream(new FileInputStream("example.dat"))) {
            int intValue = dataInputStream.readInt();
            double doubleValue = dataInputStream.readDouble();
            String stringValue = dataInputStream.readUTF();
            System.out.println("Read values: " + intValue + ", " + doubleValue + ", " + stringValue);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

#### 写入数据类型

```java
import java.io.DataOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class DataStreamWriteExample {
    public static void main(String[] args) {
        try (DataOutputStream dataOutputStream = new DataOutputStream(new FileOutputStream("example.dat"))) {
            dataOutputStream.writeInt(123);
            dataOutputStream.writeDouble(45.67);
            dataOutputStream.writeUTF("Hello, World!");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 5. 对象流（Object Streams）

对象流用于读写 Java 对象，常用的类有 `ObjectInputStream` 和 `ObjectOutputStream`。需要注意的是，读写的对象必须实现 `Serializable` 接口。

#### 读取对象

```java
import java.io.FileInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;

public class ObjectStreamReadExample {
    public static void main(String[] args) {
        try (ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream("example.obj"))) {
            MyObject myObject = (MyObject) objectInputStream.readObject();
            System.out.println("Read object: " + myObject);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

#### 写入对象

```java
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;

public class ObjectStreamWriteExample {
    public static void main(String[] args) {
        MyObject myObject = new MyObject("Hello", 123);
        try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("example.obj"))) {
            objectOutputStream.writeObject(myObject);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

class MyObject implements Serializable {
    private String message;
    private int number;

    public MyObject(String message, int number) {
        this.message = message;
        this.number = number;
    }

    @Override
    public String toString() {
        return "MyObject{message='" + message + "', number=" + number + '}';
    }
}
```

### 6. 文件流（File Streams）

文件流用于直接处理文件的输入和输出操作，常用的类有 `FileInputStream`, `FileOutputStream`, `FileReader`, 和 `FileWriter`。

#### 读取文件

```java
import java.io.FileInputStream;
import java.io.IOException;

public class FileStreamReadExample {
    public static void main(String[] args) {
        try (FileInputStream fileInputStream = new FileInputStream("example.txt")) {
            int data;
            while ((data = fileInputStream.read()) != -1) {
                System.out.print((char) data);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

#### 写入文件

```java
import java.io.FileOutputStream;
import java.io.IOException;

public class FileStreamWriteExample {
    public static void main(String[] args) {
        try (FileOutputStream fileOutputStream = new FileOutputStream("example.txt")) {
            String data = "Hello, World!";
            fileOutputStream.write(data.getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 总结

传统 IO 提供了多种处理输入和输出的方式，可以根据具体需求选择合适的流类型和类。这些方式包括字节流、字符流、缓冲流、数据流、对象流和文件流，每种方式都有其特定的使用场景和优点。通过合理选择和组合这些流，可以实现高效和灵活的 I/O 操作。


除了前面提到的传统 IO 使用方式，Java 的 `java.io` 包中还有一些其他重要的类和接口，它们提供了更多的功能和灵活性，适用于不同的 I/O 场景。以下是一些其他常用的传统 IO 类和使用方式：

### 7. 管道流（Piped Streams）

管道流用于在两个线程之间进行通信。一个线程可以将数据写入管道输出流（`PipedOutputStream`），另一个线程可以从管道输入流（`PipedInputStream`）读取数据。

#### 管道流示例

```java
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.IOException;

public class PipedStreamExample {
    public static void main(String[] args) throws IOException {
        final PipedInputStream pipedInputStream = new PipedInputStream();
        final PipedOutputStream pipedOutputStream = new PipedOutputStream(pipedInputStream);

        Thread writerThread = new Thread(() -> {
            try {
                pipedOutputStream.write("Hello from writer thread".getBytes());
                pipedOutputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        });

        Thread readerThread = new Thread(() -> {
            try {
                int data;
                while ((data = pipedInputStream.read()) != -1) {
                    System.out.print((char) data);
                }
                pipedInputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        });

        writerThread.start();
        readerThread.start();
    }
}
```

### 8. 推回输入流（PushbackInputStream）

`PushbackInputStream` 允许将读取的字节推回到输入流中，这在需要预读数据并决定如何处理时非常有用。

#### 推回输入流示例

```java
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.PushbackInputStream;

public class PushbackInputStreamExample {
    public static void main(String[] args) throws IOException {
        byte[] data = "Hello, World!".getBytes();
        try (PushbackInputStream pushbackInputStream = new PushbackInputStream(new ByteArrayInputStream(data))) {
            int byteRead = pushbackInputStream.read();
            System.out.print((char) byteRead); // 输出 'H'

            // 推回一个字节
            pushbackInputStream.unread(byteRead);

            byteRead = pushbackInputStream.read();
            System.out.print((char) byteRead); // 再次输出 'H'
        }
    }
}
```

### 9. 序列输入流（SequenceInputStream）

`SequenceInputStream` 允许将多个输入流串联在一起，形成一个连续的输入流。

#### 序列输入流示例

```java
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.SequenceInputStream;
import java.util.Vector;

public class SequenceInputStreamExample {
    public static void main(String[] args) throws IOException {
        ByteArrayInputStream input1 = new ByteArrayInputStream("Hello ".getBytes());
        ByteArrayInputStream input2 = new ByteArrayInputStream("World!".getBytes());

        Vector<ByteArrayInputStream> inputStreams = new Vector<>();
        inputStreams.add(input1);
        inputStreams.add(input2);

        try (SequenceInputStream sequenceInputStream = new SequenceInputStream(inputStreams.elements())) {
            int data;
            while ((data = sequenceInputStream.read()) != -1) {
                System.out.print((char) data);
            }
        }
    }
}
```

### 10. 过滤流（Filter Streams）

过滤流用于对其他流进行装饰，提供附加的功能。常见的过滤流包括 `FilterInputStream` 和 `FilterOutputStream`。

#### 自定义过滤流示例

```java
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

class UpperCaseInputStream extends FilterInputStream {
    protected UpperCaseInputStream(InputStream in) {
        super(in);
    }

    @Override
    public int read() throws IOException {
        int c = super.read();
        return (c == -1 ? c : Character.toUpperCase((char) c));
    }

    @Override
    public int read(byte[] b, int off, int len) throws IOException {
        int result = super.read(b, off, len);
        for (int i = off; i < off + result; i++) {
            b[i] = (byte) Character.toUpperCase((char) b[i]);
        }
        return result;
    }
}

public class FilterStreamExample {
    public static void main(String[] args) throws IOException {
        byte[] data = "Hello, World!".getBytes();
        try (InputStream inputStream = new UpperCaseInputStream(new ByteArrayInputStream(data))) {
            int c;
            while ((c = inputStream.read()) != -1) {
                System.out.print((char) c);
            }
        }
    }
}
```

### 11. 打印流（Print Streams）

`PrintStream` 和 `PrintWriter` 提供了方便的方法来打印各种数据类型，包括 `int`, `float`, `String` 等。

#### 打印流示例

```java
import java.io.FileNotFoundException;
import java.io.PrintStream;

public class PrintStreamExample {
    public static void main(String[] args) {
        try (PrintStream printStream = new PrintStream("example.txt")) {
            printStream.println("Hello, World!");
            printStream.printf("This is a number: %d%n", 42);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

### 12. 随机访问文件（Random Access Files）

`RandomAccessFile` 允许读取和写入文件的任意位置，适用于需要频繁读写文件的应用场景。

#### 随机访问文件示例

```java
import java.io.IOException;
import java.io.RandomAccessFile;

public class RandomAccessFileExample {
    public static void main(String[] args) {
        try (RandomAccessFile file = new RandomAccessFile("example.txt", "rw")) {
            file.writeUTF("Hello, World!");
            file.seek(0); // 移动到文件开始位置
            String data = file.readUTF();
            System.out.println(data);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 总结

Java 的传统 IO 提供了丰富的类和接口，适用于各种输入和输出操作。除了字节流、字符流、缓冲流、数据流、对象流和文件流外，管道流、推回输入流、序列输入流、过滤流、打印流和随机访问文件等也提供了强大的功能和灵活性。通过合理选择和组合这些流，可以实现高效和灵活的 I/O 操作，满足不同的应用需求。



### NIO（New I/O）的使用方式

Java NIO（New I/O）是Java平台提供的一组新的I/O API，旨在提高I/O操作的性能和灵活性。NIO引入了许多新的概念和组件，如通道（Channel）、缓冲区（Buffer）和选择器（Selector），使得I/O操作更加高效和灵活。以下是NIO的主要使用方式及其相关概念。

#### 1. 通道（Channel）

通道是Java NIO中的核心概念，类似于流（Stream），但通道可以进行非阻塞的读写操作。常见的通道类型包括：

- **FileChannel**：用于文件的读写操作。
- **SocketChannel**：用于网络套接字的读写操作。
- **ServerSocketChannel**：用于监听TCP连接的服务器套接字通道。
- **DatagramChannel**：用于UDP连接的通道。

##### 使用示例：

```java
// FileChannel 示例
try (FileChannel fileChannel = new RandomAccessFile("example.txt", "rw").getChannel()) {
    // 创建缓冲区
    ByteBuffer buffer = ByteBuffer.allocate(48);

    // 从文件中读取数据到缓冲区
    int bytesRead = fileChannel.read(buffer);

    while (bytesRead != -1) {
        buffer.flip(); // 切换到读模式

        while (buffer.hasRemaining()) {
            System.out.print((char) buffer.get()); // 读取缓冲区中的数据
        }

        buffer.clear(); // 清空缓冲区
        bytesRead = fileChannel.read(buffer); // 继续读取
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

#### 2. 缓冲区（Buffer）

缓冲区是NIO中用于数据存储的容器，所有的读写操作都通过缓冲区进行。缓冲区的基本类型包括：

- **ByteBuffer**：用于存储字节数据。
- **CharBuffer**：用于存储字符数据。
- **IntBuffer**：用于存储整数数据。
- **FloatBuffer**：用于存储浮点数数据。

##### 使用示例：

```java
// ByteBuffer 示例
ByteBuffer buffer = ByteBuffer.allocate(48);

// 写入数据到缓冲区
buffer.put((byte) 0x01);
buffer.put((byte) 0x02);

// 切换到读模式
buffer.flip();

// 读取缓冲区中的数据
while (buffer.hasRemaining()) {
    byte b = buffer.get();
    System.out.println(b);
}
```

#### 3. 选择器（Selector）

选择器用于管理多个通道的非阻塞I/O操作。通过选择器，可以在一个单独的线程中管理多个通道，从而提高I/O操作的效率。

##### 使用示例：

```java
try {
    // 打开选择器
    Selector selector = Selector.open();

    // 打开通道
    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
    serverSocketChannel.bind(new InetSocketAddress(8080));
    serverSocketChannel.configureBlocking(false);

    // 将通道注册到选择器
    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

    while (true) {
        // 选择一组键，其相应的通道已准备好进行I/O操作
        selector.select();

        // 获取选择的键集
        Set<SelectionKey> selectedKeys = selector.selectedKeys();
        Iterator<SelectionKey> iterator = selectedKeys.iterator();

        while (iterator.hasNext()) {
            SelectionKey key = iterator.next();

            if (key.isAcceptable()) {
                // 接受新的连接
                SocketChannel clientChannel = serverSocketChannel.accept();
                clientChannel.configureBlocking(false);
                clientChannel.register(selector, SelectionKey.OP_READ);
            } else if (key.isReadable()) {
                // 读取数据
                SocketChannel clientChannel = (SocketChannel) key.channel();
                ByteBuffer buffer = ByteBuffer.allocate(256);
                clientChannel.read(buffer);
                buffer.flip();
                System.out.println("Received: " + new String(buffer.array()).trim());
            }

            iterator.remove();
        }
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

#### 4. 文件操作（File Operations）

NIO提供了更高效的文件操作方式，尤其是大文件的读写操作。通过 `FileChannel`和 `MappedByteBuffer`，可以实现内存映射文件的高效读写。

##### 使用示例：

```java
// 内存映射文件示例
try (RandomAccessFile file = new RandomAccessFile("example.txt", "rw");
     FileChannel fileChannel = file.getChannel()) {
  
    // 将文件的前1024字节映射到内存
    MappedByteBuffer mappedBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, 1024);

    // 写入数据到内存映射缓冲区
    mappedBuffer.put("Hello, NIO!".getBytes());

    // 读取数据
    mappedBuffer.flip();
    byte[] data = new byte[mappedBuffer.remaining()];
    mappedBuffer.get(data);
    System.out.println(new String(data));
} catch (IOException e) {
    e.printStackTrace();
}
```

### 总结

Java NIO提供了一套高效、灵活的I/O操作API，适用于各种高性能I/O需求。通过通道、缓冲区和选择器，NIO能够实现非阻塞的I/O操作，从而提高系统的并发性能和资源利用率。掌握NIO的使用方式，可以显著提升Java程序的I/O处理能力。



### NIO（New I/O）的其他使用方式

除了已经介绍的基本功能和高级功能，Java NIO还有一些其他重要的使用方式和组件，进一步增强了I/O操作的灵活性和性能。以下是一些其他重要的NIO功能及其使用示例。

#### 10. 异步通道（Asynchronous Channels）

Java NIO.2引入了异步通道，允许异步的I/O操作。异步通道包括 `AsynchronousFileChannel`、`AsynchronousSocketChannel`和 `AsynchronousServerSocketChannel`等，通过回调函数或 `Future`对象处理异步操作的结果。

##### 使用示例：

```java
// 异步文件通道示例
try {
    Path path = Paths.get("example.txt");
    AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, StandardOpenOption.READ);

    ByteBuffer buffer = ByteBuffer.allocate(1024);
    Future<Integer> result = fileChannel.read(buffer, 0);

    // 等待异步操作完成
    while (!result.isDone()) {
        System.out.println("Reading file...");
    }

    // 获取读取的字节数
    int bytesRead = result.get();
    System.out.println("Bytes read: " + bytesRead);

    buffer.flip();
    byte[] data = new byte[buffer.remaining()];
    buffer.get(data);
    System.out.println("File content: " + new String(data));
} catch (IOException | InterruptedException | ExecutionException e) {
    e.printStackTrace();
}
```

#### 11. 文件属性（File Attributes）

NIO提供了对文件属性的支持，通过 `Files`类可以读取和设置文件的各种属性，如大小、创建时间、修改时间、权限等。

##### 使用示例：

```java
// 文件属性示例
try {
    Path path = Paths.get("example.txt");

    // 获取文件大小
    long size = Files.size(path);
    System.out.println("File size: " + size + " bytes");

    // 获取文件创建时间
    FileTime creationTime = Files.getAttribute(path, "creationTime", LinkOption.NOFOLLOW_LINKS);
    System.out.println("Creation time: " + creationTime);

    // 设置文件只读属性
    Files.setAttribute(path, "dos:readonly", true, LinkOption.NOFOLLOW_LINKS);

    // 检查文件是否只读
    boolean isReadOnly = (boolean) Files.getAttribute(path, "dos:readonly", LinkOption.NOFOLLOW_LINKS);
    System.out.println("Is read-only: " + isReadOnly);
} catch (IOException e) {
    e.printStackTrace();
}
```

#### 12. 文件系统（File Systems）

NIO提供了对文件系统的支持，通过 `FileSystems`类可以访问和操作不同的文件系统，如本地文件系统、ZIP文件系统等。

##### 使用示例：

```java
// 文件系统示例
try {
    // 获取默认文件系统
    FileSystem fileSystem = FileSystems.getDefault();
    System.out.println("Default file system: " + fileSystem);

    // 列出根目录
    Iterable<Path> rootDirectories = fileSystem.getRootDirectories();
    for (Path rootDirectory : rootDirectories) {
        System.out.println("Root directory: " + rootDirectory);
    }

    // 使用ZIP文件系统
    Map<String, String> env = new HashMap<>();
    env.put("create", "true");
    URI uri = URI.create("jar:file:/path/to/your.zip");
    try (FileSystem zipFileSystem = FileSystems.newFileSystem(uri, env)) {
        Path zipPath = zipFileSystem.getPath("/example.txt");
        Files.write(zipPath, "Hello, ZIP!".getBytes(StandardCharsets.UTF_8));
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

#### 13. Watch Service（文件变化监控）

NIO提供了文件变化监控的功能，通过 `WatchService`可以监控目录中的文件变化，如创建、删除和修改等。

##### 使用示例：

```java
// Watch Service 示例
try {
    // 获取文件系统的WatchService
    WatchService watchService = FileSystems.getDefault().newWatchService();

    // 监控目录
    Path path = Paths.get("/path/to/directory");
    path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY);

    // 无限循环等待事件
    while (true) {
        WatchKey key = watchService.take();
        for (WatchEvent<?> event : key.pollEvents()) {
            WatchEvent.Kind<?> kind = event.kind();
            Path fileName = (Path) event.context();
            System.out.println(kind.name() + ": " + fileName);
        }

        // 重置key
        boolean valid = key.reset();
        if (!valid) {
            break;
        }
    }
} catch (IOException | InterruptedException e) {
    e.printStackTrace();
}
```

#### 14. 通道之间的数据传输（Channel-to-Channel Transfers）

NIO提供了通道之间直接传输数据的功能，通过 `transferTo`和 `transferFrom`方法，可以高效地在两个通道之间传输数据。

##### 使用示例：

```java
// 通道之间的数据传输示例
try (FileChannel sourceChannel = new FileInputStream("source.txt").getChannel();
     FileChannel targetChannel = new FileOutputStream("target.txt").getChannel()) {

    // 使用transferTo方法传输数据
    long position = 0;
    long count = sourceChannel.size();
    sourceChannel.transferTo(position, count, targetChannel);
} catch (IOException e) {
    e.printStackTrace();
}
```

### 总结

Java NIO提供了一系列强大且灵活的I/O操作功能，不仅包括基本的通道、缓冲区和选择器，还包括异步通道、文件属性、文件系统、文件变化监控以及通道之间的数据传输等。这些功能使得NIO在处理高性能I/O操作时更加高效和灵活，适用于各种复杂的I/O需求。通过掌握这些高级功能，可以显著提升Java程序的I/O处理能力和性能。



### NIO（New I/O）的其他使用方式

Java NIO提供了丰富的功能和组件，除了已经介绍的基本和高级功能外，还有一些其他重要的使用方式和特性。以下是一些其他重要的NIO功能及其使用示例。

#### 15. ByteBuffer的高级操作

ByteBuffer是NIO中非常重要的组件，除了基本的读写操作外，还提供了一些高级操作，如slice、duplicate和compact等。

##### 使用示例：

```java
// ByteBuffer 高级操作示例
ByteBuffer buffer = ByteBuffer.allocate(10);

// 写入数据
for (int i = 0; i < 10; i++) {
    buffer.put((byte) i);
}

// 切换到读模式
buffer.flip();

// 切片（Slice）操作
ByteBuffer sliceBuffer = buffer.slice();
sliceBuffer.position(2);
sliceBuffer.limit(6);
ByteBuffer newSlice = sliceBuffer.slice();
while (newSlice.hasRemaining()) {
    System.out.print(newSlice.get() + " ");
}
System.out.println();

// 复制（Duplicate）操作
ByteBuffer duplicateBuffer = buffer.duplicate();
duplicateBuffer.position(2);
duplicateBuffer.put((byte) 99);
buffer.flip();
while (buffer.hasRemaining()) {
    System.out.print(buffer.get() + " ");
}
System.out.println();

// 压缩（Compact）操作
buffer.compact();
buffer.put((byte) 100);
buffer.flip();
while (buffer.hasRemaining()) {
    System.out.print(buffer.get() + " ");
}
System.out.println();
```

#### 16. Scatter/Gather I/O

Scatter/Gather I/O是NIO中的一项功能，允许将数据从一个通道分散（Scatter）到多个缓冲区，或者将多个缓冲区中的数据聚集（Gather）到一个通道。

##### 使用示例：

```java
// Scatter/Gather I/O 示例
try (RandomAccessFile file = new RandomAccessFile("example.txt", "rw");
     FileChannel channel = file.getChannel()) {

    // 创建多个缓冲区
    ByteBuffer header = ByteBuffer.allocate(128);
    ByteBuffer body = ByteBuffer.allocate(1024);

    // Scatter 读取
    ByteBuffer[] bufferArray = {header, body};
    channel.read(bufferArray);

    // 切换到读模式
    header.flip();
    body.flip();

    // 打印缓冲区内容
    System.out.println("Header: " + new String(header.array(), StandardCharsets.UTF_8));
    System.out.println("Body: " + new String(body.array(), StandardCharsets.UTF_8));

    // Gather 写入
    ByteBuffer[] buffers = {ByteBuffer.wrap("Header".getBytes()), ByteBuffer.wrap("Body".getBytes())};
    channel.write(buffers);
} catch (IOException e) {
    e.printStackTrace();
}
```

#### 17. Path和Files类的高级操作

NIO的Path和Files类提供了许多高级文件操作功能，如遍历目录、符号链接、文件属性视图等。

##### 使用示例：

```java
// Path 和 Files 高级操作示例
try {
    Path path = Paths.get("example.txt");

    // 遍历目录
    Files.walk(path.getParent()).forEach(System.out::println);

    // 创建符号链接
    Path link = Paths.get("example_link.txt");
    Files.createSymbolicLink(link, path);

    // 读取符号链接
    Path target = Files.readSymbolicLink(link);
    System.out.println("Symbolic link target: " + target);

    // 文件属性视图
    BasicFileAttributes attr = Files.readAttributes(path, BasicFileAttributes.class);
    System.out.println("Creation time: " + attr.creationTime());
    System.out.println("Last access time: " + attr.lastAccessTime());
    System.out.println("Last modified time: " + attr.lastModifiedTime());

    // 设置文件权限
    Set<PosixFilePermission> perms = PosixFilePermissions.fromString("rwxr-x---");
    Files.setPosixFilePermissions(path, perms);
} catch (IOException e) {
    e.printStackTrace();
}
```

#### 18. NIO的性能优化技巧

Java NIO提供了许多性能优化的技巧和方法，如零拷贝（Zero-Copy）技术、直接缓冲区（Direct Buffer）等。

##### 使用示例：

```java
// 零拷贝示例
try (FileChannel sourceChannel = new FileInputStream("source.txt").getChannel();
     FileChannel targetChannel = new FileOutputStream("target.txt").getChannel()) {

    // 使用transferTo方法进行零拷贝
    long position = 0;
    long count = sourceChannel.size();
    sourceChannel.transferTo(position, count, targetChannel);
} catch (IOException e) {
    e.printStackTrace();
}

// 直接缓冲区示例
ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024);
directBuffer.put("Direct Buffer Example".getBytes());
directBuffer.flip();
while (directBuffer.hasRemaining()) {
    System.out.print((char) directBuffer.get());
}
System.out.println();
```

### 总结

Java NIO提供了一系列强大且灵活的I/O操作功能，不仅包括基本的通道、缓冲区和选择器，还包括高级的ByteBuffer操作、Scatter/Gather I/O、Path和Files类的高级操作以及性能优化技巧等。这些功能使得NIO在处理高性能I/O操作时更加高效和灵活，适用于各种复杂的I/O需求。通过掌握这些高级功能，可以显著提升Java程序的I/O处理能力和性能。



### NIO（New I/O）的其他使用方式

Java NIO不仅提供了丰富的I/O操作功能，还有一些其他重要的特性和使用方式，进一步增强了I/O操作的灵活性和性能。以下是一些其他重要的NIO功能及其使用示例。

#### 19. AsynchronousSocketChannel和AsynchronousServerSocketChannel

Java NIO.2引入了异步网络通道，支持异步的网络I/O操作。`AsynchronousSocketChannel`用于异步连接和数据传输，`AsynchronousServerSocketChannel`用于异步接受连接。

##### 使用示例：

```java
// 异步客户端示例
try {
    AsynchronousSocketChannel clientChannel = AsynchronousSocketChannel.open();
    Future<Void> future = clientChannel.connect(new InetSocketAddress("localhost", 8080));
    future.get(); // 等待连接完成

    ByteBuffer buffer = ByteBuffer.allocate(1024);
    buffer.put("Hello, AsynchronousSocketChannel!".getBytes());
    buffer.flip();
    Future<Integer> writeResult = clientChannel.write(buffer);
    writeResult.get(); // 等待写入完成

    buffer.clear();
    Future<Integer> readResult = clientChannel.read(buffer);
    readResult.get(); // 等待读取完成

    buffer.flip();
    byte[] data = new byte[buffer.remaining()];
    buffer.get(data);
    System.out.println("Received: " + new String(data));
} catch (IOException | InterruptedException | ExecutionException e) {
    e.printStackTrace();
}

// 异步服务器示例
try {
    AsynchronousServerSocketChannel serverChannel = AsynchronousServerSocketChannel.open();
    serverChannel.bind(new InetSocketAddress(8080));

    serverChannel.accept(null, new CompletionHandler<AsynchronousSocketChannel, Void>() {
        @Override
        public void completed(AsynchronousSocketChannel result, Void attachment) {
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            result.read(buffer, buffer, new CompletionHandler<Integer, ByteBuffer>() {
                @Override
                public void completed(Integer bytesRead, ByteBuffer buffer) {
                    buffer.flip();
                    byte[] data = new byte[buffer.remaining()];
                    buffer.get(data);
                    System.out.println("Received: " + new String(data));
                }

                @Override
                public void failed(Throwable exc, ByteBuffer attachment) {
                    exc.printStackTrace();
                }
            });
            serverChannel.accept(null, this); // 接受下一个连接
        }

        @Override
        public void failed(Throwable exc, Void attachment) {
            exc.printStackTrace();
        }
    });

    // 保持服务器运行
    Thread.currentThread().join();
} catch (IOException | InterruptedException e) {
    e.printStackTrace();
}
```

#### 20. FileVisitor接口和Files.walkFileTree方法

NIO提供了 `FileVisitor`接口和 `Files.walkFileTree`方法，用于遍历文件树和执行文件操作。

##### 使用示例：

```java
// FileVisitor 示例
Path startPath = Paths.get("/path/to/start");
try {
    Files.walkFileTree(startPath, new SimpleFileVisitor<Path>() {
        @Override
        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
            System.out.println("Visiting file: " + file);
            return FileVisitResult.CONTINUE;
        }

        @Override
        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
            System.out.println("Visiting directory: " + dir);
            return FileVisitResult.CONTINUE;
        }

        @Override
        public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
            System.err.println("Failed to visit file: " + file);
            return FileVisitResult.CONTINUE;
        }
    });
} catch (IOException e) {
    e.printStackTrace();
}
```

#### 21. PathMatcher接口

NIO提供了 `PathMatcher`接口，用于匹配文件路径，支持glob和正则表达式模式。

##### 使用示例：

```java
// PathMatcher 示例
PathMatcher matcher = FileSystems.getDefault().getPathMatcher("glob:**/*.txt");

try {
    Files.walk(Paths.get("/path/to/start")).forEach(path -> {
        if (matcher.matches(path)) {
            System.out.println("Matched file: " + path);
        }
    });
} catch (IOException e) {
    e.printStackTrace();
}
```

#### 22. UserPrincipal和GroupPrincipal

NIO提供了对文件所有者和组的支持，通过 `UserPrincipal`和 `GroupPrincipal`接口可以获取和设置文件的所有者和组。

##### 使用示例：

```java
// UserPrincipal 和 GroupPrincipal 示例
Path path = Paths.get("example.txt");

try {
    // 获取文件所有者
    UserPrincipal owner = Files.getOwner(path);
    System.out.println("Owner: " + owner.getName());

    // 设置文件所有者
    UserPrincipal newOwner = FileSystems.getDefault().getUserPrincipalLookupService().lookupPrincipalByName("newOwner");
    Files.setOwner(path, newOwner);

    // 获取文件组
    PosixFileAttributes attrs = Files.readAttributes(path, PosixFileAttributes.class);
    GroupPrincipal group = attrs.group();
    System.out.println("Group: " + group.getName());

    // 设置文件组
    GroupPrincipal newGroup = FileSystems.getDefault().getUserPrincipalLookupService().lookupPrincipalByGroupName("newGroup");
    Files.getFileAttributeView(path, PosixFileAttributeView.class).setGroup(newGroup);
} catch (IOException e) {
    e.printStackTrace();
}
```

#### 23. SecureDirectoryStream

NIO提供了 `SecureDirectoryStream`接口，用于安全地操作目录和文件，避免TOCTOU（Time-of-Check to Time-of-Use）漏洞。

##### 使用示例：

```java
// SecureDirectoryStream 示例
Path dir = Paths.get("/path/to/dir");

try (SecureDirectoryStream<Path> stream = Files.newDirectoryStream(dir, SecureDirectoryStream.class)) {
    for (Path entry : stream) {
        System.out.println("Entry: " + entry);
    }

    // 创建新的文件
    stream.newByteChannel(Paths.get("newFile.txt"), EnumSet.of(StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE));
} catch (IOException e) {
    e.printStackTrace();
}
```

### 总结

Java NIO提供了一系列强大且灵活的I/O操作功能，不仅包括基本的通道、缓冲区和选择器，还包括异步网络通道、文件树遍历、路径匹配、文件所有者和组管理以及安全目录流等。这些功能使得NIO在处理高性能I/O操作时更加高效和灵活，适用于各种复杂的I/O需求。通过掌握这些高级功能，可以显著提升Java程序的I/O处理能力和性能。



### NIO（New I/O）的其他使用方式

Java NIO提供了丰富的功能和组件，除了已经介绍的基本和高级功能外，还有一些其他重要的使用方式和特性，进一步增强了I/O操作的灵活性和性能。以下是一些其他重要的NIO功能及其使用示例。

#### 24. Files类的流操作

NIO中的 `Files`类提供了许多用于文件操作的静态方法，包括流操作，如读取和写入文件时使用流。

##### 使用示例：

```java
// 使用 Files 类的流操作读写文件
Path path = Paths.get("example.txt");

try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {
    String line;
    while ((line = reader.readLine()) != null) {
        System.out.println(line);
    }
} catch (IOException e) {
    e.printStackTrace();
}

try (BufferedWriter writer = Files.newBufferedWriter(path, StandardCharsets.UTF_8, StandardOpenOption.APPEND)) {
    writer.write("Appending new line");
} catch (IOException e) {
    e.printStackTrace();
}
```

#### 25. Files类的批量操作

NIO中的 `Files`类提供了批量操作文件的方法，如批量删除、批量复制等。

##### 使用示例：

```java
// 批量删除文件
Path dir = Paths.get("exampleDir");
try (Stream<Path> files = Files.list(dir)) {
    files.forEach(file -> {
        try {
            Files.delete(file);
        } catch (IOException e) {
            e.printStackTrace();
        }
    });
} catch (IOException e) {
    e.printStackTrace();
}

// 批量复制文件
Path sourceDir = Paths.get("sourceDir");
Path targetDir = Paths.get("targetDir");
try (Stream<Path> files = Files.list(sourceDir)) {
    files.forEach(file -> {
        try {
            Files.copy(file, targetDir.resolve(file.getFileName()), StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            e.printStackTrace();
        }
    });
} catch (IOException e) {
    e.printStackTrace();
}
```

#### 26. 文件锁的高级操作

NIO中的文件锁不仅可以用于简单的文件锁定，还可以进行高级操作，如部分文件锁定和非阻塞锁定。

##### 使用示例：

```java
// 部分文件锁定示例
try (RandomAccessFile file = new RandomAccessFile("example.txt", "rw");
     FileChannel fileChannel = file.getChannel()) {

    // 锁定文件的前100个字节
    FileLock lock = fileChannel.lock(0, 100, false);

    try {
        // 进行文件操作
        ByteBuffer buffer = ByteBuffer.allocate(48);
        buffer.put("Locked Partial File Content".getBytes());
        buffer.flip();
        while (buffer.hasRemaining()) {
            fileChannel.write(buffer);
        }
    } finally {
        // 释放文件锁
        lock.release();
    }
} catch (IOException e) {
    e.printStackTrace();
}

// 非阻塞锁定示例
try (RandomAccessFile file = new RandomAccessFile("example.txt", "rw");
     FileChannel fileChannel = file.getChannel()) {

    // 尝试获取文件锁
    FileLock lock = fileChannel.tryLock();
    if (lock != null) {
        try {
            // 进行文件操作
            ByteBuffer buffer = ByteBuffer.allocate(48);
            buffer.put("Non-blocking File Lock Content".getBytes());
            buffer.flip();
            while (buffer.hasRemaining()) {
                fileChannel.write(buffer);
            }
        } finally {
            // 释放文件锁
            lock.release();
        }
    } else {
        System.out.println("File is already locked by another process.");
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

#### 27. 文件系统监听

Java NIO不仅可以监听单个目录的变化，还可以通过扩展实现对整个文件系统的变化进行监听。

##### 使用示例：

```java
// 文件系统监听示例
try {
    WatchService watchService = FileSystems.getDefault().newWatchService();
  
    // 监听多个目录
    Path dir1 = Paths.get("/path/to/dir1");
    Path dir2 = Paths.get("/path/to/dir2");
    dir1.register(watchService, StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY);
    dir2.register(watchService, StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY);

    // 无限循环等待事件
    while (true) {
        WatchKey key = watchService.take();
        for (WatchEvent<?> event : key.pollEvents()) {
            WatchEvent.Kind<?> kind = event.kind();
            Path fileName = (Path) event.context();
            System.out.println(kind.name() + ": " + fileName);
        }

        // 重置key
        boolean valid = key.reset();
        if (!valid) {
            break;
        }
    }
} catch (IOException | InterruptedException e) {
    e.printStackTrace();
}
```

#### 28. 文件通道的高级操作

NIO中的文件通道不仅支持基本的读写操作，还支持高级操作，如截断文件和强制写入。

##### 使用示例：

```java
// 文件通道高级操作示例
try (RandomAccessFile file = new RandomAccessFile("example.txt", "rw");
     FileChannel fileChannel = file.getChannel()) {

    // 截断文件
    fileChannel.truncate(100);

    // 强制写入
    ByteBuffer buffer = ByteBuffer.allocate(48);
    buffer.put("Force Write Content".getBytes());
    buffer.flip();
    while (buffer.hasRemaining()) {
        fileChannel.write(buffer);
    }
    fileChannel.force(true);
} catch (IOException e) {
    e.printStackTrace();
}
```

### 总结

Java NIO提供了一系列强大且灵活的I/O操作功能，不仅包括基本的通道、缓冲区和选择器，还包括流操作、批量文件操作、文件锁的高级操作、文件系统监听以及文件通道的高级操作等。这些功能使得NIO在处理高性能I/O操作时更加高效和灵活，适用于各种复杂的I/O需求。通过掌握这些高级功能，可以显著提升Java程序的I/O处理能力和性能。



### NIO（New I/O）的其他使用方式

Java NIO提供了丰富的功能和组件，除了已经介绍的基本和高级功能外，还有一些其他重要的使用方式和特性，进一步增强了I/O操作的灵活性和性能。以下是一些其他重要的NIO功能及其使用示例。

#### 29. 内存映射文件的读写性能优化

内存映射文件（Memory-Mapped Files）可以将文件的一部分或全部映射到内存中，从而提高文件读写的性能，尤其是对大文件的读写操作。

##### 使用示例：

```java
// 内存映射文件的读写性能优化示例
try (RandomAccessFile file = new RandomAccessFile("largefile.dat", "rw");
     FileChannel fileChannel = file.getChannel()) {

    // 将文件的前10MB映射到内存
    MappedByteBuffer mappedBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, 10 * 1024 * 1024);

    // 写入数据到内存映射缓冲区
    for (int i = 0; i < 1024; i++) {
        mappedBuffer.putInt(i);
    }

    // 读取数据
    mappedBuffer.flip();
    for (int i = 0; i < 1024; i++) {
        System.out.println(mappedBuffer.getInt());
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

#### 30. 文件属性视图（File Attribute Views）

NIO提供了多种文件属性视图，如 `BasicFileAttributeView`、`DosFileAttributeView`、`PosixFileAttributeView`、`AclFileAttributeView`等，可以获取和设置文件的各种属性。

##### 使用示例：

```java
// 文件属性视图示例
Path path = Paths.get("example.txt");

try {
    // 使用BasicFileAttributeView获取文件属性
    BasicFileAttributeView basicView = Files.getFileAttributeView(path, BasicFileAttributeView.class);
    BasicFileAttributes basicAttrs = basicView.readAttributes();
    System.out.println("Creation time: " + basicAttrs.creationTime());
    System.out.println("Last modified time: " + basicAttrs.lastModifiedTime());

    // 使用DosFileAttributeView设置文件属性
    DosFileAttributeView dosView = Files.getFileAttributeView(path, DosFileAttributeView.class);
    dosView.setReadOnly(true);
    DosFileAttributes dosAttrs = dosView.readAttributes();
    System.out.println("Is read-only: " + dosAttrs.isReadOnly());

    // 使用PosixFileAttributeView设置文件权限
    PosixFileAttributeView posixView = Files.getFileAttributeView(path, PosixFileAttributeView.class);
    Set<PosixFilePermission> perms = PosixFilePermissions.fromString("rwxr-x---");
    posixView.setPermissions(perms);
    PosixFileAttributes posixAttrs = posixView.readAttributes();
    System.out.println("Permissions: " + PosixFilePermissions.toString(posixAttrs.permissions()));
} catch (IOException e) {
    e.printStackTrace();
}
```

#### 31. 文件通道的锁定和解锁

NIO中的文件通道支持文件锁定和解锁操作，可以实现对文件的部分或全部进行独占锁定或共享锁定。

##### 使用示例：

```java
// 文件通道的锁定和解锁示例
try (RandomAccessFile file = new RandomAccessFile("example.txt", "rw");
     FileChannel fileChannel = file.getChannel()) {

    // 锁定文件的前100个字节
    FileLock lock = fileChannel.lock(0, 100, false);

    try {
        // 进行文件操作
        ByteBuffer buffer = ByteBuffer.allocate(48);
        buffer.put("Locked File Content".getBytes());
        buffer.flip();
        while (buffer.hasRemaining()) {
            fileChannel.write(buffer);
        }
    } finally {
        // 释放文件锁
        lock.release();
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

#### 32. 文件系统的挂载和卸载

NIO提供了对文件系统的挂载和卸载操作，可以在程序中动态挂载和卸载文件系统。

##### 使用示例：

```java
// 文件系统的挂载和卸载示例
try {
    // 挂载ZIP文件系统
    Map<String, String> env = new HashMap<>();
    env.put("create", "true");
    URI uri = URI.create("jar:file:/path/to/your.zip");
    try (FileSystem zipFileSystem = FileSystems.newFileSystem(uri, env)) {
        Path zipPath = zipFileSystem.getPath("/example.txt");
        Files.write(zipPath, "Hello, ZIP!".getBytes(StandardCharsets.UTF_8));
    }

    // 挂载完毕后进行操作
    Path zipFilePath = Paths.get("/path/to/your.zip");
    try (FileSystem zipFileSystem = FileSystems.newFileSystem(zipFilePath, null)) {
        Path zipPath = zipFileSystem.getPath("/example.txt");
        List<String> lines = Files.readAllLines(zipPath, StandardCharsets.UTF_8);
        lines.forEach(System.out::println);
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

#### 33. 文件系统的符号链接和硬链接

NIO提供了对符号链接和硬链接的支持，可以创建、读取和删除符号链接和硬链接。

##### 使用示例：

```java
// 符号链接和硬链接示例
Path target = Paths.get("example.txt");
Path link = Paths.get("example_link.txt");

try {
    // 创建符号链接
    Files.createSymbolicLink(link, target);

    // 读取符号链接
    Path realPath = Files.readSymbolicLink(link);
    System.out.println("Symbolic link points to: " + realPath);

    // 创建硬链接
    Path hardLink = Paths.get("example_hardlink.txt");
    Files.createLink(hardLink, target);

    // 验证硬链接
    boolean isSameFile = Files.isSameFile(target, hardLink);
    System.out.println("Is same file: " + isSameFile);
} catch (IOException e) {
    e.printStackTrace();
}
```

### 总结

Java NIO提供了一系列强大且灵活的I/O操作功能，不仅包括基本的通道、缓冲区和选择器，还包括内存映射文件、文件属性视图、文件锁定和解锁、文件系统的挂载和卸载以及符号链接和硬链接等。这些功能使得NIO在处理高性能I/O操作时更加高效和灵活，适用于各种复杂的I/O需求。通过掌握这些高级功能，可以显著提升Java程序的I/O处理能力和性能。
